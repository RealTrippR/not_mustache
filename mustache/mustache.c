/***************************************************
Copyright (C) 2025 Tripp R

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
***************************************************/

#include "mustache.h"
#include <string.h>
#include <streql/streqlasm.h>
#include <math.h>
#include <stdio.h>

#ifndef NDEBUG
#include <assert.h>
#endif // !NDEBUG


#if defined(_MSC_VER)
#define alloca(N) _alloca(N)
#else
#define alloca(N) __builtin_alloca(N)
#endif 

#define min(X, Y) ((X) < (Y) ? (X) : (Y))
#define array_count(A) (sizeof(A)/sizeof(A[0]))

typedef struct {
    mustache_slice buf;
    uint32_t count;
    uint32_t MAX_COUNT;
} parent_stack;

typedef enum
{
    STRUCTURE_TYPE_VAR,
    STRUCTURE_TYPE_SCOPED_POUND,
    STRUCTURE_TYPE_SCOPED_CARET,
    STRUCTURE_TYPE_COMMENT,
    STRUCTURE_TYPE_CLOSE,
    STRUCTURE_TYPE_SKIP_RANGE,
    STRUCTURE_TYPE_ROOT,
    STRUCTURE_TYPE_LEN
} STRUCTURE_TYPE;

typedef struct {
    uint32_t lineBegin;
    uint32_t lineEnd;
} standalone_data;

typedef struct structure structure;
typedef struct structure {
    structure* pNext;
    structure* pLast;
    STRUCTURE_TYPE type;

    uint32_t contentsFirst; // the first byte after the second '{'
    uint32_t contentsEnd; // the first closing '}'
    uint32_t precedingMustacheLen;

    mustache_param* param;
    standalone_data* standalone;
} structure;

typedef struct {
    structure* pNext;
    structure* pLast;
    STRUCTURE_TYPE type;

    uint32_t skipFirst;
    uint32_t skipLast;
    uint32_t precedingMustacheLen;

} skip_range_structure;

typedef struct {
    structure* pNext;
    structure* pLast;
    STRUCTURE_TYPE type;

    uint32_t contentsFirst;
    uint32_t contentsEnd;
    uint32_t precedingMustacheLen;

    mustache_param* param;

    uint32_t interiorFirst; // the first byte of the interior var name
    uint32_t interiorEnd; // the last byte + 1 of the interior (the closing ')') after the name
} len_structure;

typedef struct {
    structure* pNext;
    structure* pLast;
    STRUCTURE_TYPE type;

    uint32_t contentsFirst; // the first byte after the second '{'
    uint32_t contentsEnd; // the first closing '}'
    uint32_t precedingMustacheLen;

    mustache_param* param;
    standalone_data* standalone;

    bool escapeHTML;
} var_structure;

typedef struct {
    structure* pNext;
    structure* pLast;
    STRUCTURE_TYPE type;
    uint32_t contentsFirst; // the first byte after the second '{'
    uint32_t contentsEnd; // the first closing '}'

    mustache_param* param;
    standalone_data* standalone;
    uint32_t precedingMustacheLen;

    uint32_t interiorFirst; // the first byte of the interior
    uint32_t interiorEnd; // the end of the interior - the first opening bracket of it's closing mustache '{{/name}}'

    uint32_t curIdx; // current child index
    mustache_param* curChild;

} scoped_structure;

typedef struct {
    structure* pNext;
    structure* pLast;
    STRUCTURE_TYPE type;

    uint32_t contentsFirst; // the first byte after the second '{'
    uint32_t contentsEnd; // the first closing '}'
    uint32_t precedingMustacheLen;

    mustache_param* param;
    standalone_data* standalone;

    scoped_structure* parent;
} close_structure;



int32_t strtoi32(const char* str, uint8_t bufflen, int32_t* strLenOut)
{
    if (strLenOut) /* 0-init */
        *strLenOut = 0;
    int32_t num = 0;
    char negative = 0u;
    if (*str == '-') {
        negative = 1;
        str++;
    }

    const uint8_t max_digits = bufflen;

    int32_t i = 0;
    for (; i < max_digits; ++i)
    {
        if (i == max_digits) {
            if (!(str[i] == '\r' || str[i] == '\n') && !isspace(str[i])) {
                if (strLenOut)
                    *strLenOut = 0;
                return 0;
            }
        }
        else {
            if (str[i] < '0' || str[i] > '9') {
                break;
            }
            else {
                if (negative == 0) {
                    if (num > (INT32_MAX - (str[i] - '0')) / 10) {
                        if (strLenOut)
                            *strLenOut = 0;
                        return 0;
                    }
                }
                else {
                    if (num > (int32_t)(abs(INT32_MIN) - (str[i] - '0')) / 10) {
                        if (strLenOut)
                            *strLenOut = 0;
                        return 0;
                    }
                }
                num = num * 10 + (str[i] - 48);
                if (strLenOut)
                    (*strLenOut)++;
            }
        }
    }
    if (negative)
        num *= -1;
    return num;
}

static void parent_stack_pop(parent_stack* stack)
{
#ifndef NDEBUG
    if (stack->count == 0) {
        assert(00 && "parent_stack_pop: INVALID CALL, STACK WILL UNDERFLOW!");
    }
#endif // !NDEBUG

    stack->count--;
}

static uint8_t parent_stack_push(parent_stack* stack, scoped_structure* parent)
{
#ifndef NDEBUG
    if (!(parent->type == STRUCTURE_TYPE_SCOPED_CARET || parent->type == STRUCTURE_TYPE_SCOPED_POUND)) {
        assert(00 && "parent_stack_push: param IS NOT A PARENT.");
    }
    mustache_param* p = parent->param;
    if (!(p->type == MUSTACHE_PARAM_LIST || p->type == MUSTACHE_PARAM_OBJECT)) {
        assert(00 && "parent_stack_push: param IS NOT A PARENT.");
    }
#endif // !NDEBUG

    if (stack->count == stack->MAX_COUNT) {
        return MUSTACHE_ERR_OVERFLOW;
    }

    uint8_t** pointers = (uint8_t**)stack->buf.u;
    pointers[stack->count] = (uint8_t*)parent;
    stack->count++;

    return MUSTACHE_SUCCESS;
};

//returns the last structure on the stack.
static scoped_structure* parent_stack_last(parent_stack* stack)
{
#ifndef NDEBUG
    if (stack->count == 0) {
        assert(00 && "parent_stack_last: INVALID CALL, stack.count MUST NOT BE EMPTY!");
    }
#endif // !NDEBUG

    scoped_structure** pointers = (scoped_structure**)stack->buf.u;
    return pointers[stack->count - 1];
}



static uint32_t u32_round_to_next_power_of_2(uint32_t v) {
    v--; //https://stackoverflow.com/questions/466204/rounding-up-to-next-power-of-2
    v |= v >> 1;
    v |= v >> 2;
    v |= v >> 4;
    v |= v >> 8;
    v |= v >> 16;
    v++;
    return v;
}

static uint8_t digits_i64(int64_t n) {
    if (n<0) {n = n * -1;}
    if (n < 10) return 1;
    if (n < 100) return 2;
    if (n < 1000) return 3;
    if (n < 10000) return 4;
    if (n < 100000) return 5;
    if (n < 1000000) return 6;
    if (n < 10000000) return 7;
    if (n < 100000000) return 8;
    if (n < 1000000000) return 9;
    if (n < 10000000000) return 10;
    if (n < 100000000000) return 11;
    if (n < 1000000000000) return 12;
    if (n < 10000000000000) return 13;
    if (n < 100000000000000) return 14;
    if (n < 1000000000000000) return 15;
    if (n < 10000000000000000) return 16;
    if (n < 100000000000000000) return 17;
    if (n < 1000000000000000000) return 18;
    return 0;
}


static uint8_t digits_u32(uint32_t n) {
    if (n < 10) return 1;
    if (n < 100) return 2;
    if (n < 1000) return 3;
    if (n < 10000) return 4;
    if (n < 100000) return 5;
    if (n < 1000000) return 6;
    if (n < 10000000) return 7;
    if (n < 100000000) return 8;
    if (n < 1000000000) return 9;
    if (n < 10000000000) return 10;
    if (n < 100000000000) return 11;
    if (n < 1000000000000) return 12;
    if (n < 10000000000000) return 13;
    if (n < 100000000000000) return 14;
    if (n < 1000000000000000) return 15;
    if (n < 10000000000000000) return 16;
    if (n < 100000000000000000) return 17;
    if (n < 1000000000000000000) return 18;
    return 0;
}

// returns pow(10,n) from a lookup table;
static double n_pow10(uint16_t n) {
    static const double pow10_table[] = {
        1.0,
10.0,
100.0,
1000.0,
10000.0,
100000.0,
1000000.0,
10000000.0,
100000000.0,
1000000000.0,
10000000000.0,
100000000000.0,
1000000000000.0,
10000000000000.0,
100000000000000.0,
1000000000000000.0,
10000000000000000.0,
100000000000000000.0,
1000000000000000000.0,
10000000000000000000.0,
100000000000000000000.0,
1000000000000000000000.0,
10000000000000000000000.0,
100000000000000000000000.0,
1000000000000000000000000.0,
10000000000000000000000000.0,
100000000000000000000000000.0,
1000000000000000000000000000.0,
10000000000000000000000000000.0,
100000000000000000000000000000.0,
1000000000000000000000000000000.0,
10000000000000000000000000000000.0,
100000000000000000000000000000000.0,
1000000000000000000000000000000000.0,
10000000000000000000000000000000000.0,
100000000000000000000000000000000000.0,
1000000000000000000000000000000000000.0,
10000000000000000000000000000000000000.0,
100000000000000000000000000000000000000.0,
1000000000000000000000000000000000000000.0,
10000000000000000000000000000000000000000.0,
100000000000000000000000000000000000000000.0,
1000000000000000000000000000000000000000000.0,
10000000000000000000000000000000000000000000.0,
100000000000000000000000000000000000000000000.0,
1000000000000000000000000000000000000000000000.0,
10000000000000000000000000000000000000000000000.0,
100000000000000000000000000000000000000000000000.0,
1000000000000000000000000000000000000000000000000.0,
10000000000000000000000000000000000000000000000000.0,
100000000000000000000000000000000000000000000000000.0,
1000000000000000000000000000000000000000000000000000.0,
10000000000000000000000000000000000000000000000000000.0,
100000000000000000000000000000000000000000000000000000.0,
1000000000000000000000000000000000000000000000000000000.0,
10000000000000000000000000000000000000000000000000000000.0,
100000000000000000000000000000000000000000000000000000000.0,
1000000000000000000000000000000000000000000000000000000000.0,
10000000000000000000000000000000000000000000000000000000000.0,
100000000000000000000000000000000000000000000000000000000000.0,
1000000000000000000000000000000000000000000000000000000000000.0,
10000000000000000000000000000000000000000000000000000000000000.0,
100000000000000000000000000000000000000000000000000000000000000.0,
1000000000000000000000000000000000000000000000000000000000000000.0,
10000000000000000000000000000000000000000000000000000000000000000.0,
100000000000000000000000000000000000000000000000000000000000000000.0,
1000000000000000000000000000000000000000000000000000000000000000000.0,
10000000000000000000000000000000000000000000000000000000000000000000.0,
100000000000000000000000000000000000000000000000000000000000000000000.0,
1000000000000000000000000000000000000000000000000000000000000000000000.0,
10000000000000000000000000000000000000000000000000000000000000000000000.0,
100000000000000000000000000000000000000000000000000000000000000000000000.0,
1000000000000000000000000000000000000000000000000000000000000000000000000.0,
10000000000000000000000000000000000000000000000000000000000000000000000000.0,
100000000000000000000000000000000000000000000000000000000000000000000000000.0,
1000000000000000000000000000000000000000000000000000000000000000000000000000.0,
10000000000000000000000000000000000000000000000000000000000000000000000000000.0,
100000000000000000000000000000000000000000000000000000000000000000000000000000.0,
1000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
10000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
100000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
1000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
10000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
100000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
1000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
10000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
100000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0
    };

    if (n < sizeof(pow10_table) / sizeof(pow10_table[0])) {
        return pow10_table[n];
    }
    return 0;
}

static const uint8_t* get_key_value_end(const uint8_t* start, const uint8_t* sourceEnd)
{
    while (start < sourceEnd)
    {
        if (isspace(*start) || *start == '}') {
            return start;
        }
        start++;
    }
    return NULL;
}

static int16_t i64toa(int64_t n,uint8_t* buf, size_t size)
{
    int8_t dig = digits_i64(n);
    int16_t i = 0;
    while (n!=0)
    {
        i++;
        buf[dig - i] = n % 10 + 48;
        n /= 10;
    }
    return i;
}

// returns the expected write length of a dtoa call
static uint16_t dtoalen(double value, uint16_t precision, bool trimZeros) {
    if (isnan(value)) {
        return 3;
    }
    if (isinf(value)) {
        if (value < 0) {
            return 4;
        }
        else {
            return 3;
        }
    }

    if (value < 0) {
        value = -value;
    }

    uint16_t len = 0;
    if (value < 0) {
        len++;
        value = -value;
    }

    long long int_part = (long long)value;
    double frac_part = value - (double)int_part;

    if (int_part == 0) {
        len += 1;
    }
    else {
        long long tmp = int_part;
        while (tmp > 0) {
            len++;
            tmp /= 10;
        }
    }

    if (precision > 0)
    {
        if (!trimZeros)
        {
            len += 1 + precision; 
        }
        else {
            uint16_t frac_len = 0;
            double frac = frac_part;
            for (uint16_t i = 0; i < precision; i++) 
            {
                frac *= 10.0;
                int digit = (int)frac;
                frac -= digit;
                if (digit != 0) {
                    frac_len = i + 1;
                }
            }
            if (frac_len > 0) {
                len += 1 + frac_len; // '.' 
            }
        }
    }

    return len;
}

// converts a u32 to a string and returns the end of the write position.
static uint8_t* u32toa(uint32_t value, uint8_t* buf, size_t bufsize)
{
    uint8_t digits = digits_u32(value);
    uint8_t* bufEnd = buf + bufsize - 1;
    uint8_t i = 0;
    while (value && buf < bufEnd)
    {
        uint8_t* pos = buf + digits - i - 1;
        if (pos<bufEnd) {
            *pos = value % 10 + '0';
        }
        value /= 10;
        i++;
    }
    return buf+i;
}

// converts a double to string and returns the write head
static uint8_t* dtoa(double value, uint8_t* buf, size_t size, uint16_t precision, bool trimZeros) {
    if (size == 0) return buf;

    if (isnan(value)) {
        memcpy(buf, "nan", min(size, 3));
        return buf + min(size, 3);
    }
    if (isinf(value)) {
        if (value < 0) {
            memcpy(buf, "-inf", min(size, 4));
            return buf + min(size, 4);
        }
        else {
            memcpy(buf, "inf", min(size, 3));
            return buf + min(size, 3);
        }
    }

    char* start = buf;

    if (value < 0) {
        if (size <= 1) return buf;
        *buf++ = '-';
        size--;
        value = -value;
    }

    // get integer and frac parts
    long long int_part = (long long)value;
    double frac_part = value - (double)int_part;

    // Write integer part
    int written = i64toa(int_part, buf, size);
    if (written < 0 || written >= (int)size) return buf;

    buf += written;
    size -= written;

    char frac_buf[64];
    uint8_t frac_len = 0;

    frac_part += 0.5 * pow(10, -precision);

    for (int32_t i = 0; i < precision && frac_len + 1 < (int32_t)sizeof(frac_buf); i++) {
        frac_part *= 10.0;
        int32_t digit = (int32_t)frac_part;
        frac_buf[frac_len++] = '0' + digit;
        frac_part -= digit;
    }

    if (trimZeros) {
        while (frac_len > 0 && frac_buf[frac_len - 1] == '0')
            frac_len--;
    }

    // skip '.' if no frac. digits remain
    if (frac_len == 0)
        return buf;

    // '.'
    if (size < 2) return buf;
    *buf++ = '.';
    size--;

    // write fractional digits
    for (uint8_t i = 0; i < frac_len && size > 1; i++) {
        *buf++ = frac_buf[i];
        size--;
    }

    return buf;
}


static uint64_t fseek_callback(void* udata, int64_t whence, MUSTACHE_SEEK_DIR seekdir)
{
    FILE* fptr = (FILE*)udata;

    if (seekdir == MUSTACHE_SEEK_LEN) {
        _fseeki64(fptr, 0, SEEK_END);
        uint64_t s = _ftelli64(fptr);
        rewind(fptr);
        return s;
    }
    return _fseeki64(fptr, whence, seekdir);
}

static size_t fread_callback(void* udata, uint8_t* dst, size_t dstlen)
{
    FILE* fptr = (FILE*)udata;
    return fread(dst, 1, dstlen, fptr);
}



static scoped_structure* get_scoped_close_parent(close_structure* close)
{
    structure* cur = (structure*)close;
    cur = cur->pLast;
    while (cur)
    {
        if (cur->param == close->param) {
            return (scoped_structure*)cur;
        }
        cur = cur->pLast;
    }
    return NULL;
}

static uint8_t* get_truthy_close(mustache_const_slice paramName, uint8_t* cur, uint8_t* end)
{
#ifndef NDEBUG
    if (cur == NULL || end < cur || end == NULL)
    {
        assert(00 && "get_truthy_close: INVALID CUR OR END ARGUMENT");
    }
#endif // !NDEBUG

    while (cur < end-2)
    {
        if (*cur == '{' && *(cur + 1) == '{' && *(cur + 2) == '/')
        {
            // find end
            cur += 3;

            uint8_t* cur2 = cur;
            while (cur2<end-1)
            {
                if (*cur2 == '}' && *(cur2 + 1) == '}')
                {
                    break;
                }
                cur2++;
            }

          
            uint16_t dist = cur2 - cur;
            if (paramName.len == dist && strneql(paramName.u, cur, dist))
            {
                return cur-3;
            }
        }
        cur++;
    }
    return NULL;
}

uint8_t stream_cache_add_var(mustache_template_cache* streamCache, mustache_slice srcBuffer, uint8_t* varBegin, uint8_t* varLast, uint8_t* truthyClose)
{
    uint32_t offsetBegin = varBegin - srcBuffer.u;
    uint32_t offsetEnd = varLast - srcBuffer.u;

    if (streamCache->varCount==streamCache->privMAX_VAR_COUNT) {
        return MUSTACHE_ERR_NO_SPACE;
    }
    else {
        mustache_var_info* vars = (mustache_var_info*)(streamCache->varBuffer.u);
        uint32_t truthyLen;
        if (truthyClose) {
            truthyLen = truthyClose - (varLast);
        }
        else {
            truthyLen = 0;
        }
        vars[streamCache->varCount] = (mustache_var_info){ offsetBegin, offsetEnd, truthyLen};
        streamCache->varCount++;
        return MUSTACHE_SUCCESS;
    }
};

static uint8_t* get_line_end(uint8_t* line, uint8_t* searchEnd)
{
    while (line<searchEnd)
    {
        if (*line == '\n') {
            return line;
        }
        line++;
    }
    return line;
}

static uint8_t* get_line_begin(uint8_t* line, uint8_t* searchBegin) {
    while (line!=searchBegin)
    {
        if (*line == '\n') {
            line++;
            break;
        }
        line--;
    }
    return line;
}

static MUSTACHE_TYPE get_mustache_type(uint8_t* mustacheOpen) {
    switch (*mustacheOpen)
    {
    case '!':
        return MUSTACHE_TYPE_COMMENT;
    case '^':
        return MUSTACHE_TYPE_FALSY;
    case '#':
        return MUSTACHE_TYPE_POUND;
    case '/':
        return MUSTACHE_TYPE_CLOSE;
    default:
        return MUSTACHE_TYPE_VARIABLE;
    }
}
static bool is_line_standalone(uint8_t* line, uint8_t* lineEnd)
{
    bool isInMustache = false;
    while (line < lineEnd)
    {
        if (line < lineEnd - 2) {
            if (*line == '{' && *(line + 1) == '{')
            {
                uint8_t prefix = *(line + 2);
                if (!(prefix == '#' || prefix == '^' || prefix == '!' || prefix == '/'))
                {
                    return false;
                }
                isInMustache = true;
            }
            if (*(line + 1) == '}' && *(line + 2) == '}')
            {
                isInMustache = false;
                line += 3;
                if (line >= lineEnd) {
                    return true;
                }
            }
        }
        if (!isInMustache && !isspace(*line)) {
            return false;
        }
        line++;
    }
    return true;
}

static bool is_mustache_open(uint8_t* s) {
#ifndef NDEBUG
    if (s == NULL) {
        assert(00 && "is_mustache_open: s MUST NOT BE A VALID POINTER.");
    }
#endif // !NDEBUG
    if (*s == '{' && *(s + 1) == '{') {
        return true;
    }
    return false;
}

static bool is_mustache_close(uint8_t* s) {
#ifndef NDEBUG
    if (s == NULL) {
        assert(00 && "is_mustache_open: s MUST NOT BE A VALID POINTER.");
    }
#endif // !NDEBUGs
    if (*s == '}' && *(s + 1) == '}') {
        return true;
    }
    return false;
}

static mustache_param* get_parameter(const uint8_t* nameBegin, const uint8_t* nameEnd, mustache_param* globalParams, parent_stack* parentStack)
{
    // TRAVERSE PARENT STACK
    uint16_t nameLen = nameEnd - nameBegin;
    for (int32_t i = parentStack->count-1; i >= 0; i--) {
        scoped_structure* structNode = ((scoped_structure**)parentStack->buf.u)[i];
        mustache_param* parentNode = structNode->param;

        mustache_param* node;
        uint32_t MAX_COUNT;

        if (parentNode->type == MUSTACHE_PARAM_LIST) {
            mustache_param_list* list = (mustache_param_list*)parentNode;
            MAX_COUNT = list->valueCount;
            node = list->pValues;
        }
        else if (parentNode->type == MUSTACHE_PARAM_OBJECT) {
            mustache_param_object* obj = (mustache_param_object*)obj;
            node = obj->pMembers;
            MAX_COUNT = UINT32_MAX;
        }
        else {
#ifndef NDEBUG
            assert(00 && "get_parameter: PARENT STACK IS CORRUPTED.");
#endif // !NDEBUG
            return NULL;
        }




        uint32_t c = 0;
        while (node&&c<MAX_COUNT)
        {
            if (node->name.len == nameLen &&
                strneql(node->name.u, nameBegin, nameLen))
            {
                return node;
            }
            node = node->pNext;
            c++;
        }
    }

    // TRAVERSE GLOBAL PARAMS
    while (globalParams) {
        if (globalParams->name.len == nameLen &&
            strneql(globalParams->name.u, nameBegin, nameLen))
        {
            return globalParams;
        }

        globalParams = globalParams->pNext;
    }

    return NULL;
}

static mustache_param* get_child_param(uint8_t* nameBegin, uint8_t nameLen, mustache_param* parent)
{

    mustache_param* node;
    uint32_t MAX_COUNT;

    if (parent->type == MUSTACHE_PARAM_LIST) {
        mustache_param_list* list = (mustache_param_list*)parent;
        MAX_COUNT = list->valueCount;
        node = list->pValues;
    }
    else if (parent->type == MUSTACHE_PARAM_OBJECT) {
        mustache_param_object* obj = (mustache_param_object*)obj;
        node = obj->pMembers;
        MAX_COUNT = UINT32_MAX;
    }
    else {
#ifndef NDEBUG
        assert(00 && "get_child_param: parent IS NOT A PARENT.");
#endif // !NDEBUG
    }

    uint32_t ni = 0;
    while (node && ni < MAX_COUNT)
    {
        if (node->name.len == nameLen && strneql(node->name.u, nameBegin, nameLen)) {
            return node;
        }
        node = node->pNext;
        ni++;
    }
    return NULL;
}

static uint8_t* write_variable(mustache_param* paramBASE, uint8_t* outputHead, uint8_t* outputEnd, bool escapeHTML)
{
    if (paramBASE->type == MUSTACHE_PARAM_NUMBER) {
        mustache_param_number* param = (mustache_param_number*)paramBASE;
        outputHead = dtoa(param->value, outputHead, (size_t)(outputEnd - outputHead),
            param->decimals, param->trimZeros);
    }
    else if (paramBASE->type == MUSTACHE_PARAM_BOOLEAN) {
        mustache_param_boolean* param = (mustache_param_boolean*)paramBASE;
        if (param->value) {
            uint8_t dist = min((int8_t)strlen("true"), outputEnd - outputHead);
            memcpy(outputHead, "true", dist);
            outputHead += dist;
        }
        else {
            uint8_t dist = min((int8_t)strlen("false"), outputEnd - outputHead);
            memcpy(outputHead, "false", dist);
            outputHead += dist;
        }
    }
    else if (paramBASE->type == MUSTACHE_PARAM_STRING) {
        mustache_param_string* param = (mustache_param_string*)paramBASE;

        uint32_t distToEnd = outputEnd - outputHead;

        if (escapeHTML) {
            /*
                '&': '&amp;',
                '<': '&lt;',
                '>': '&gt;',
                '"': '&quot;',
                "'": '&#039;'
            */
            uint8_t* cur = param->str.u;
            uint8_t* end = param->str.u + param->str.len;
            while (cur<end && outputHead < outputEnd)
            {
                if (*cur == '&') {
                    uint8_t dist = min(outputEnd - outputHead, strlen("&amp;"));
                    memcpy(outputHead, "&amp;", dist);
                    outputHead += dist;
                }
                else if (*cur == '<') {
                    uint8_t dist = min(outputEnd - outputHead, strlen("&lt;"));
                    memcpy(outputHead, "&lt;", dist);
                    outputHead += dist;
                }
                else if (*cur == '>') {
                    uint8_t dist = min(outputEnd - outputHead, strlen("&gt;"));
                    memcpy(outputHead, "&gt;", dist);
                    outputHead += dist;
                }
                else if (*cur == '"') {
                    uint8_t dist = min(outputEnd - outputHead, strlen("&quot;"));
                    memcpy(outputHead, "&quot;", dist);
                    outputHead += dist;
                }
                else if (*cur == '\'') {
                    uint8_t dist = min(outputEnd - outputHead, strlen("&#039;"));
                    memcpy(outputHead, "&#039;", dist);
                    outputHead += dist;
                }
                else {
                    *outputHead = *cur;
                    outputHead++;
                }
                cur++;
            }
        }
        else {
            uint32_t dist = min(distToEnd, param->str.len);
            memcpy(outputHead, param->str.u, dist);
            outputHead += dist;
        }
    }
   
    return outputHead;
}

static uint8_t is_parent(mustache_param* param) {
    if (param->type == MUSTACHE_PARAM_LIST || param->type == MUSTACHE_PARAM_OBJECT) {
        return true;
    }
    return false;
}


static uint8_t* get_mustache_close(uint8_t* inputHead, uint8_t* inputEnd) {
    while (inputHead < inputEnd)
    {
        if (is_mustache_close(inputHead)) {
            return inputHead;
        }
        inputHead++;
    }
    return NULL;
}

static uint8_t* get_scoped_interior_end(uint8_t* interiorFirst, uint8_t* end)
{
    uint32_t no = 1;
    while (interiorFirst <end)
    {
        uint8_t prefix = *(interiorFirst + 2);
        if (is_mustache_open(interiorFirst) && (prefix=='#' || prefix=='^')) {
            no++;
            interiorFirst += 2;
        }
        else if (is_mustache_open(interiorFirst) && prefix=='/') {
            no--;
            if (no == 0) {
                return interiorFirst;
            }
        }

        interiorFirst++;
    }
    return NULL;
}

static bool is_truthy(mustache_param* p)
{
    if (p->type == MUSTACHE_PARAM_STRING) {
        mustache_param_string* param = (mustache_param_string*)p;
        if (param->str.len > 0) {
            return true;
        } else {
            return false;
        }
    }
    else if (p->type == MUSTACHE_PARAM_BOOLEAN) {
        mustache_param_boolean* param = (mustache_param_boolean*)p;
        return param->value;
    }
    else if (p->type == MUSTACHE_PARAM_NUMBER) {
        mustache_param_number* param = (mustache_param_number*)p;
        return (bool)param->value;
    }
    else if (p->type == MUSTACHE_PARAM_LIST) {
        mustache_param_list* param = (mustache_param_list*)p;
        return param->valueCount;
    }
    if (p) {
        return true;
    }
    return false;
}

static uint8_t source_to_structured(mustache_parser* parser, structure* structureRoot, uint8_t* inputFirst, uint8_t* inputHead, uint8_t* inputEnd)
{
    structure* last_struct = structureRoot;
    while (inputHead<inputEnd)
    {
        if (is_mustache_open(inputHead))
        {
            uint8_t precedingStacheLen=2;
            uint8_t* first = inputHead+2;
            uint8_t* end = get_mustache_close(first, inputEnd);
            structure* mstruct = NULL;
            // handle len case
            if (strneql(first, "len(",4))
            { 
                if (inputHead + 4 >= inputEnd) {
                    return MUSTACHE_ERR_INVALID_TEMPLATE;
                }
                uint8_t* interiorFirst = first + 4;
                uint8_t* interiorEnd;
                inputHead = interiorFirst;
                // get closing ')'
                while (inputHead < inputEnd)
                {
                    if (*inputHead == ')') {
                        interiorEnd = inputHead;
                        break;
                    }
                    inputHead++;
                }
                mstruct = parser->alloc(parser, sizeof(len_structure));
                if (!mstruct) { return MUSTACHE_ERR_ALLOC; }
                mstruct->type = STRUCTURE_TYPE_LEN;
                mstruct->pNext = NULL;

                len_structure* asLen = (len_structure*)mstruct;
                asLen->param = NULL;
                asLen->interiorFirst = (interiorFirst - inputFirst);
                asLen->interiorEnd = interiorEnd - inputFirst;

                inputHead = end + 2;
            }
            // handle escape case
            else if (*(inputHead-1)=='/') {
                mstruct = parser->alloc(parser, sizeof(skip_range_structure));
                if (!mstruct) { return MUSTACHE_ERR_ALLOC; }
                mstruct->type = STRUCTURE_TYPE_SKIP_RANGE;
                mstruct->pNext = NULL;

                skip_range_structure* asSkip = (skip_range_structure*)mstruct;
                asSkip->skipFirst = (inputHead - inputFirst)-1;
                asSkip->skipLast = inputHead - inputFirst;

                inputHead = end+2;
            }
            else if (*first == '/' || *first == '!')
            {
                if (*first == '/') {
                    mstruct = parser->alloc(parser, sizeof(close_structure));
                    if (!mstruct) {
                        return MUSTACHE_ERR_ALLOC;
                    }
                    mstruct->type = STRUCTURE_TYPE_CLOSE;
                    close_structure* asClosed = (close_structure*)mstruct;
                    asClosed->parent = NULL;
                }
                else {
                    mstruct = parser->alloc(parser, sizeof(structure));
                    if (!mstruct) {
                        return MUSTACHE_ERR_ALLOC;
                    }
                    mstruct->type = STRUCTURE_TYPE_COMMENT;
                }
                mstruct->param = NULL;
                mstruct->pNext = NULL;
           
                // check if it's standalone
                bool standlone = false;
                uint8_t* lineEnd;
                // check if the starting cond. line is standalone. If so, skip it.
                uint8_t* lineBeg = get_line_begin(first, inputFirst);
                lineEnd = get_line_end(first, inputEnd);
                if (lineEnd) {
                    standlone = is_line_standalone(lineBeg, lineEnd);
                    if (standlone) {
                      
                        mstruct->standalone = parser->alloc(parser,sizeof(standalone_data));
                        if (!mstruct->standalone) {
                            return MUSTACHE_ERR_ALLOC;}
                        mstruct->standalone->lineBegin = lineBeg - inputFirst;
                        mstruct->standalone->lineEnd = lineEnd - inputFirst;
                    }
                    else {
                        mstruct->standalone = NULL;
                    }
                }
                else {
                    mstruct->standalone = NULL;
                }
            }
            else if (*first == '^' || *first == '#')
            {
                mstruct = parser->alloc(parser, sizeof(scoped_structure));
                mstruct->param = NULL;
                mstruct->pNext = NULL;
                if (!mstruct) {
                    return MUSTACHE_ERR_ALLOC; }

                if (*first == '^') {
                    mstruct->type = STRUCTURE_TYPE_SCOPED_CARET;
                }
                else {
                    mstruct->type = STRUCTURE_TYPE_SCOPED_POUND;
                }

                // check if it's standalone
                bool standlone = false;
                uint8_t* lineEnd;
                // check if the starting cond. line is standalone. If so, skip it.
                uint8_t* lineBeg = get_line_begin(first, inputFirst);
                lineEnd = get_line_end(first, inputEnd);
                if (lineEnd) {
                    standlone = is_line_standalone(lineBeg, lineEnd);
                    if (standlone) {

                        mstruct->standalone = parser->alloc(parser, sizeof(standalone_data));
                        if (!mstruct->standalone) {
                            return MUSTACHE_ERR_ALLOC;
                        }
                        mstruct->standalone->lineBegin = lineBeg - inputFirst;
                        mstruct->standalone->lineEnd = lineEnd - inputFirst;
                    }
                    else {
                        mstruct->standalone = NULL;
                    }
                }
                else {
                    mstruct->standalone = NULL;
                }

                scoped_structure* asScoped = (scoped_structure*)mstruct;
                asScoped->interiorFirst = end - inputFirst + 2;
                uint8_t* int_end = get_scoped_interior_end(end+2,inputEnd);
                if (!int_end) {
                    asScoped->interiorEnd = 0;
                    return MUSTACHE_ERR_INVALID_TEMPLATE;
                }
                asScoped->interiorEnd = int_end - inputFirst;
            }
            else {
                mstruct = parser->alloc(parser, sizeof(var_structure));
                mstruct->param = NULL;
                mstruct->pNext = NULL;
                if (!mstruct) {
                    return MUSTACHE_ERR_ALLOC;
                }

                mstruct->type = STRUCTURE_TYPE_VAR;

                var_structure* asVar = (var_structure*)mstruct;

                if (*first == '&') {
                    first++;
                    asVar->escapeHTML = false;
                    precedingStacheLen = 3;
                } else {
                    asVar->escapeHTML = true;
                }
            }

            if (mstruct->type != STRUCTURE_TYPE_SKIP_RANGE) {
                mstruct->contentsFirst = first - inputFirst;
                mstruct->contentsEnd = end - inputFirst;
            }
            inputHead = end + 1;

            last_struct->pNext = mstruct;
            mstruct->pLast = last_struct;
            mstruct->precedingMustacheLen = precedingStacheLen;
            last_struct = mstruct;
        }
        
        inputHead++;
    }
    
    return MUSTACHE_SUCCESS;
}


static uint8_t* mwrite(uint8_t* outputHead, uint8_t* outputEnd, const uint8_t* sourceBeg, const uint8_t* sourceEnd)
{
    if (sourceBeg > sourceEnd) {
        return outputHead;
    }
    
    size_t a = sourceEnd - sourceBeg;
    size_t b = outputEnd - outputHead;
    size_t s = min((sourceEnd- sourceBeg), (outputEnd- outputHead));
    memcpy(outputHead, sourceBeg, s);
    return outputHead+s;
}


void eval_jump(structure* mstruct, const uint8_t* m_name_first, const uint8_t* m_name_end, const uint8_t* input, uint8_t* outputEnd, uint8_t** outputHead, const uint8_t** lastNonEscaped) {
    if (mstruct->standalone) {
        const uint8_t* t = input + mstruct->standalone->lineBegin;
        if (t > *lastNonEscaped) {
            *outputHead = mwrite(*outputHead, outputEnd, *lastNonEscaped, t);
        }
        *lastNonEscaped = input + mstruct->standalone->lineEnd + 1;
    }
    else {
        const uint8_t* t = m_name_first - 3;
        if (t > *lastNonEscaped) {
            *outputHead = mwrite(*outputHead, outputEnd, *lastNonEscaped, t);
        }
        *lastNonEscaped = m_name_end + strlen("{{");
    }
}

static uint32_t get_parent_child_count(mustache_param* parent)
{
#ifndef NDEBUG
    if (parent->type != MUSTACHE_PARAM_OBJECT && parent->type != MUSTACHE_PARAM_LIST) {
        assert(00 && "get_parent_child_count: parent IS NOT A VALID PARENT.");
    }
#endif // !NDEBUG
    if (parent->type == MUSTACHE_PARAM_LIST) {
        mustache_param_list* asList = (mustache_param_list*)parent;
        return asList->valueCount;
    }
    else {
        uint32_t c = 0;
        while (parent)
        {
            c++;
            parent = parent->pNext;
        }
        return c;
    }
}

static mustache_param* get_nth_child(mustache_param* parent, int32_t idx) 
{
#ifndef NDEBUG
    if (parent->type != MUSTACHE_PARAM_OBJECT && parent->type != MUSTACHE_PARAM_LIST) {
        assert(00 && "get_nth_child: parent IS NOT A VALID PARENT.");
    }
#endif // !NDEBUG
    uint32_t childCount = get_parent_child_count(parent);
    if (idx < 0) {
        idx = childCount +idx;
    }

    uint32_t i = 0;
    mustache_param* child = ((mustache_param_object*)parent)->pMembers;
    while (i!=idx && child && i < childCount)
    {
        i++;
        child = child->pNext;
    }
    return child;
}


static mustache_param* resolve_param_member(mustache_param* root, const uint8_t* strFirst, const uint8_t* strEnd)
{
#ifndef NDEBUG
    if (*strFirst != '.' && *strFirst != '[') {
        assert(00 && "resolve_param_member: strFirst must be a string parameter chain, i.e. '.member.name'");
    }
#endif // !NDEBUG

    if (strFirst+1 == strEnd) {
        return root;
    }

    const uint8_t* cur = strFirst;

    mustache_param* param = root;
    const uint8_t* lastDot = NULL;
    while (cur <= strEnd)
    {
        if (*cur == '[') {
            const uint8_t* intFirst = cur+1;
            while (*cur != ']' || cur == strEnd) {
                cur++;
            }
            // resolve member
            const uint8_t* intEnd = cur;

            int32_t index = strtoi32(intFirst, intEnd - intFirst, NULL);
            mustache_param* child = get_nth_child(root, index);
            if (!child)
                return NULL;
            param = child;
        }
        else if (*cur == '.' || cur == strEnd)
        {    
            if (lastDot) {

                const uint8_t* nameBegin = lastDot + 1;
                const uint8_t* nameEnd = cur;
                uint32_t nameLen = nameEnd - nameBegin;

                uint32_t i;
                if (param->type == MUSTACHE_PARAM_LIST) {
                    mustache_param_list* asList = (mustache_param_list*)param;
                    i = asList->valueCount;
                }
                else {
                    i = UINT32_MAX;
                }

                param = ((mustache_param_list*)param)->pValues;
                while (param && i > 0)
                {
                    if (nameLen == param->name.len && strneql(nameBegin, param->name.u, nameLen)) {
                        break;
                    }
                    param = param->pNext;
                    i--;
                }

                if (!param) {
                    return NULL;
                }
            }
            lastDot = cur;
        }
        cur++;
    }

    return param;
}

uint8_t write_structured(mustache_slice outputBuffer, uint8_t** oh, mustache_const_slice inputBuffer, uint8_t* inputEnd, structure* structureRoot, 
                         mustache_param* globalParams, parent_stack* parentStack)
{
    structure* mstruct = structureRoot->pNext; // SKIP ROOT

    // INPUT
    const uint8_t* inputHead = inputBuffer.u;
    const uint8_t* input=inputBuffer.u;

    // OUTPUT
    uint8_t* outputHead = outputBuffer.u;
    uint8_t* outputEnd = outputBuffer.u + outputBuffer.len;

    const uint8_t* lastNonEscaped = inputHead;
    while (mstruct)
    {
        if (mstruct->type == STRUCTURE_TYPE_SKIP_RANGE) {
            skip_range_structure* asSkipRange = (skip_range_structure*)mstruct;
            const uint8_t* t = input + asSkipRange->skipFirst;
            inputHead = t;
            outputHead = mwrite(outputHead, outputEnd, lastNonEscaped, inputHead);
            t = input + asSkipRange->skipLast;
            lastNonEscaped = t;
        }
        else if (mstruct->type == STRUCTURE_TYPE_LEN)
        {
            const uint8_t* m_len_str_first = input + mstruct->contentsFirst;
            const uint8_t* m_len_str_end = input + mstruct->contentsEnd;

            len_structure* asLen = (len_structure*)mstruct;
            const uint8_t* int_begin = input + asLen->interiorFirst;
            const uint8_t* int_end = input + asLen->interiorEnd;


            outputHead = mwrite(outputHead, outputEnd, lastNonEscaped, m_len_str_first - mstruct->precedingMustacheLen);


            if (!asLen->param) {
                mstruct->param = get_parameter(int_begin, int_end, globalParams, parentStack);
            }
            if (asLen->param) {
                uint32_t cc = get_parent_child_count(mstruct->param);
                outputHead = u32toa(cc, outputHead, (size_t)(outputEnd - outputHead));
                lastNonEscaped = m_len_str_end + strlen("}}");
            }
        }
        else if (mstruct->type == STRUCTURE_TYPE_VAR) 
        {
            var_structure* asVar = (var_structure*)mstruct;
            const uint8_t* m_name_first = input + mstruct->contentsFirst;
            const uint8_t* m_name_end = input + mstruct->contentsEnd;
            const uint32_t nameLen = m_name_end - m_name_first;

            outputHead = mwrite(outputHead, outputEnd, lastNonEscaped, m_name_first - mstruct->precedingMustacheLen);
            lastNonEscaped = m_name_end + strlen("{{");

            // HANDLE '.' CASE
            if (*m_name_first == '.')
            {
                scoped_structure* parent = parent_stack_last(parentStack);
                mustache_param* m_child = parent->curChild;
                // resolve '.' or chains '.member.name'
                mustache_param* member = resolve_param_member(m_child, m_name_first, m_name_end);
                if (member) {
                    outputHead = write_variable(member, outputHead, outputEnd, asVar->escapeHTML);
                }
            }
            else if (!mstruct->param) {
                const uint8_t* m_first_end = m_name_first;
                while (m_first_end<m_name_end) {
                    if (*m_first_end == '.' || *m_first_end == '[') {
                        break;
                    }
                    m_first_end++;
                }


                mstruct->param = get_parameter(m_name_first, m_first_end, globalParams, parentStack);
                if (!mstruct->param) {
                    goto skip_node;
                }

                if (m_first_end != m_name_end) {
                    mustache_param* member = resolve_param_member(mstruct->param, m_first_end, m_name_end);
                    if (member) {
                        outputHead = write_variable(member, outputHead, outputEnd, asVar->escapeHTML);
                    }
                }
                else {
                    outputHead = write_variable(mstruct->param, outputHead, outputEnd, asVar->escapeHTML);
                }
            }
        }
        else if (mstruct->type == STRUCTURE_TYPE_SCOPED_CARET || mstruct->type == STRUCTURE_TYPE_SCOPED_POUND) {
            scoped_structure* asScoped = (scoped_structure*)mstruct;
        
            const uint8_t* m_name_first = input + mstruct->contentsFirst+1;
            const uint8_t* m_name_end = input + mstruct->contentsEnd;

            if (!mstruct->param) {
                mstruct->param = get_parameter(m_name_first, m_name_end, globalParams, parentStack);
                if (!mstruct->param) {
                    goto skip_node;
                }
            }

            asScoped->curIdx = 0;
            
            if (mstruct->type == STRUCTURE_TYPE_SCOPED_POUND && is_parent(mstruct->param)) 
            {
                parent_stack_push(parentStack, asScoped);

                mustache_param_object* pAsObj = (mustache_param_object*)asScoped->param;
                asScoped->curChild = pAsObj->pMembers;

                if (mstruct->standalone) {
                    const uint8_t* t = input + mstruct->standalone->lineBegin;
                    outputHead = mwrite(outputHead, outputEnd, lastNonEscaped, t);
                    lastNonEscaped = input + mstruct->standalone->lineEnd + strlen("\n");
                }
                else {
                    const uint8_t* t = m_name_first - strlen("{{x");
                    outputHead = mwrite(outputHead, outputEnd, lastNonEscaped, t);
                    lastNonEscaped = m_name_end + strlen("{{");
                }
            } 
            else if (mstruct->type == STRUCTURE_TYPE_SCOPED_POUND || mstruct->type==STRUCTURE_TYPE_SCOPED_CARET) 
            {
                
                bool truthy = is_truthy(mstruct->param);
                if ((mstruct->type == STRUCTURE_TYPE_SCOPED_POUND && truthy) || (mstruct->type == STRUCTURE_TYPE_SCOPED_CARET && !truthy))
                {
                    if (mstruct->standalone) {
                        const uint8_t* t = input + mstruct->standalone->lineBegin;
                        outputHead = mwrite(outputHead, outputEnd, lastNonEscaped, t);
                        lastNonEscaped = input + mstruct->standalone->lineEnd + strlen("\n");
                    }
                    else {
                        const uint8_t* t = m_name_first - strlen("{{x");
                        outputHead = mwrite(outputHead, outputEnd, lastNonEscaped, t);
                        lastNonEscaped = m_name_end + strlen("{{");
                    }
                }
                else {
                    uint32_t nameLen = m_name_end - m_name_first;
                    const uint8_t* t;
                    if (mstruct->standalone) {
                        t = input + mstruct->standalone->lineBegin;
                    } else {
                        t = m_name_first - strlen("{{x");
                        //outputHead=write_identation(outputHead, );
                    }
                    outputHead = mwrite(outputHead, outputEnd, lastNonEscaped, t);
                    lastNonEscaped = input + asScoped->interiorEnd+nameLen+strlen("{{x}}");
                }
            }
        }
        else if (mstruct->type == STRUCTURE_TYPE_COMMENT || mstruct->type == STRUCTURE_TYPE_CLOSE) 
        {
            const uint8_t* m_name_first = input + mstruct->contentsFirst+1;
            const uint8_t* m_name_end = input + mstruct->contentsEnd;

            if (mstruct->type == STRUCTURE_TYPE_CLOSE)
            {
                if (!mstruct->param) {
                    mstruct->param = get_parameter(m_name_first, m_name_end, globalParams, parentStack);
                }

                close_structure* asClose = (close_structure*)mstruct;
                if (!asClose->parent) {
                    asClose->parent = get_scoped_close_parent(asClose);
                }
                if (!asClose->parent) {
                    return MUSTACHE_ERR_INVALID_TEMPLATE;
                }

                scoped_structure* parent = asClose->parent;

                if (parent->param) {
                    if (parent->param->type == MUSTACHE_PARAM_LIST)
                    {
                        mustache_param_list* param = (mustache_param_list*)parent->param;
                        parent->curIdx++;
                        parent->curChild = parent->curChild->pNext;
                        if (parent->curIdx < param->valueCount && parent->curChild)
                        {

                            eval_jump(mstruct, m_name_first, m_name_end, input, outputEnd, &outputHead, &lastNonEscaped);
                            //outputHead = mwrite(outputHead, outputEnd, lastNonEscaped, m_name_first - strlen("{{/"));
                            // go to parent next again
                            mstruct = (structure*)parent;
                            eval_jump(mstruct, m_name_first, m_name_end, input, outputEnd, &outputHead, &lastNonEscaped);
                            goto skip_node;
                        }
                        else if (mstruct->param && is_parent(mstruct->param)) {
                            parent_stack_pop(parentStack);
                        }
                    }
                }


            }

            eval_jump(mstruct, m_name_first, m_name_end, input, outputEnd, &outputHead, &lastNonEscaped);
        }

    skip_node:
        mstruct = mstruct->pNext;
    }


    outputHead = mwrite(outputHead, outputEnd, lastNonEscaped, inputEnd);
    *oh = outputHead;
    return MUSTACHE_SUCCESS;
}

void mustache_tructure_chain_free(mustache_parser* p, mustache_structure* structure_chain)
{
    structure* root = (structure*)structure_chain;
    root = root->pNext;
    while (root)
    {
        structure* next = root->pNext;
        p->free(p,root);
        root = next;
    }
}



uint8_t mustache_parse_file(mustache_parser* parser, mustache_const_slice filename, mustache_structure* structChain, mustache_param* params, mustache_slice sourceBuffer, mustache_slice parseBuffer, void* parseCallbackUdata, mustache_parse_callback parseCallback)
{
#ifndef NDEBUG
    if (filename.len > 2048) {
        assert(00 && "mustache_parse_file: SUCH A LARGE FILENAME MAY RESULT IN PROGRAM INSTABILITY!");
    }
#endif
    // tragically fopen requires a null terminated string, and there is no workaround even for an all-around 
    // system specific design, it's possible on Windows but not on Linux to my knowledge :(
    uint8_t* filenameNT = alloca(filename.len + 1);
    memcpy(filenameNT, filename.u, filename.len);
    filenameNT[filename.len] = 0;

    FILE* fptr;
    fptr = fopen(filenameNT, "rb");
    if (!fptr) {
        return MUSTACHE_ERR_FILE_OPEN;
    }

    // parse in chunks
    mustache_stream stream = {
        .udata = fptr,
        .readCallback = fread_callback,
        .seekCallback = fseek_callback,
    };

    uint8_t err = mustache_parse_stream(parser, &stream, structChain, params, parseBuffer, sourceBuffer, parseCallbackUdata, parseCallback);
    fclose(fptr);
    return err;
}



uint8_t mustache_parse_stream(mustache_parser* parser, mustache_stream* stream, mustache_structure* structChain,
    mustache_param* params, mustache_slice inputBuffer, mustache_slice outputBuffer, void* parseCallbackUdata, mustache_parse_callback parseCallback)
{
    uint8_t* inputHead = inputBuffer.u;
    uint8_t* inputBeg = inputBuffer.u;

    uint8_t* mustacheOpen = NULL;
    uint8_t* mustacheClose = inputBuffer.u;

    size_t streamLen = stream->seekCallback(stream->udata, 0, MUSTACHE_SEEK_LEN);
    size_t readBytes = stream->readCallback(stream->udata, inputBuffer.u, inputBuffer.len);
    if (readBytes < streamLen) {
        return MUSTACHE_ERR_NO_SPACE;
    }

    uint8_t* inputEnd = inputBuffer.u + readBytes;


    if (readBytes < 4 || readBytes >= UINT32_MAX-3) {
        return MUSTACHE_ERR_ARGS;
    }

    uint8_t* outputHead = outputBuffer.u;
    uint8_t* outputEnd = outputBuffer.u + outputBuffer.len;

    parent_stack parentStack = {
        .buf = parser->parentStackBuf,
        .count = 0,
        .MAX_COUNT = parser->parentStackBuf.len / sizeof(void*)
    };


    structure structureRoot = { .type=STRUCTURE_TYPE_ROOT }; 
    MUSTACHE_RES err;
    if (!structureRoot.pNext) {
        err = source_to_structured(parser, &structureRoot, inputBuffer.u, inputHead, inputEnd);
        if (err) {
            return err;
        }
    }

    err = write_structured(
        outputBuffer, &outputHead,
        (mustache_const_slice){ inputBuffer.u,inputBuffer.len },
        inputBuffer.u + readBytes,
        &structureRoot, params, &parentStack
    );

    if (err) {
        return err;
    }

    mustache_slice parsedSlice = {
        .u = outputBuffer.u,
        .len = outputHead - outputBuffer.u,
    };
    parseCallback(parser, parseCallbackUdata, parsedSlice);

    return MUSTACHE_SUCCESS;
}

















/* =#==#==#==#==#==#==#==#==#==#==#==#==#==#==#==#==#==#==#==#==#= */
/* -+- -+- -+- -+- -+- -+-  JSON  PARSING  -+- -+- -+- -+- -+- -+- */
/* =#==#==#==#==#==#==#==#==#==#==#==#==#==#==#==#==#==#==#==#==#= */

uint8_t mustache_JSON_to_param_chain_from_disk(mustache_parser* parser, mustache_const_slice filename, mustache_param** paramRoot)
{
#ifndef NDEBUG
    if (filename.len > 2048) {
        assert(00 && "mustache_parse_file: SUCH A LARGE FILENAME MAY RESULT IN PROGRAM INSTABILITY!");
    }
#endif
    // tragically fopen requires a null terminated string, and there is no workaround even for an all-around 
    // system specific design, it's possible on Windows but not on Linux to my knowledge :(
    uint8_t* filenameNT = alloca(filename.len + 1);
    memcpy(filenameNT, filename.u, filename.len);
    filenameNT[filename.len] = 0;

    FILE* fptr;
    fptr = fopen(filenameNT, "rb");
    if (!fptr) {
        return MUSTACHE_ERR_FILE_OPEN;
    }

    fseek(fptr, 0, SEEK_END);
    uint32_t fileLen = ftell(fptr);
    rewind(fptr);

    void* JSON_buf;
    bool isBufferOnStack = fileLen > (16384);

    if (!isBufferOnStack) {
        JSON_buf = parser->alloc(parser, fileLen);
    }
    else {
        JSON_buf = alloca(fileLen);
    }

    fread(JSON_buf, 1, fileLen, fptr);

    uint8_t err = mustache_JSON_to_param_chain(parser, (mustache_const_slice){ JSON_buf, fileLen}, paramRoot, false);

    fclose(fptr);
    if (!isBufferOnStack) {
        parser->free(parser, JSON_buf);
    }
    return err;
}


static const uint8_t* JSON_get_object_close(const uint8_t* openingBracket, const uint8_t* sourceEnd)
{
#ifndef NDEBUG
    if (*openingBracket != '{') {
        assert(00 && "JSON_get_object_close: INVALID CALL, openingBracket MUST BE A PTR TO A '{'");
    }
#endif // !NDEBUG

    uint32_t depth = 0;
    while (openingBracket!=sourceEnd)
    {
        if (*openingBracket == '{') {
            depth++;
        }
        if (*openingBracket == '}') {
            depth--;
            if (depth == 0) {
                return openingBracket;
            }
        }
        openingBracket++;
    }
    return NULL;
}

static const uint8_t* JSON_get_list_close(const uint8_t* openingBracket, const uint8_t* sourceEnd)
{
#ifndef NDEBUG
    if (*openingBracket != '[') {
        assert(00 && "JSON_get_object_close: INVALID CALL, openingBracket MUST BE A PTR TO A '{'");
    }
#endif // !NDEBUG

    uint32_t depth = 0;
    while (openingBracket != sourceEnd)
    {
        if (*openingBracket == '[') {
            depth++;
        }
        if (*openingBracket == ']') {
            depth--;
            if (depth == 0) {
                return openingBracket;
            }
        }
        openingBracket++;
    }
    return NULL;
}


static const uint8_t* JSON_get_string_end(const uint8_t* strFirst, const uint8_t* sourceEnd)
{
#ifndef NDEBUG
    if (*strFirst == '\"') {
        assert(00 && "JSON_get_string_end: INVALID CALL, strFirst MUST BE THE FIRST CHAR AFTER QUOTATION MARK OF THE STRING VALUE.");
    }
#endif // !NDEBUG

    while (strFirst < sourceEnd)
    {
        if (*strFirst == '"') {
            return strFirst;
        }
        strFirst++;
    }

    return NULL;
}


static const uint8_t* JSON_get_number_end(const uint8_t* numFirst, const uint8_t* sourceEnd)
{
#ifndef NDEBUG
    if (!isdigit(*numFirst)) {
        assert(00 && "JSON_get_string_end: INVALID CALL, numFirst MUST BE A PTR TO THE FIRST DIGIT OF THE NUMBER.");
    }
#endif // !NDEBUG

    while (numFirst < sourceEnd)
    {
        if (!(isdigit(*numFirst) || *numFirst == '.')) {
            return numFirst;
        }
        numFirst++;
    }

    return NULL;
}

static void JSON_number_to_mustache_number(mustache_param_number* param, const uint8_t* numBegin, const uint8_t* numEnd)
{
    // first, find dec. place (if it exists)
    const uint8_t* cur = numBegin;
    const uint8_t* dec = NULL;
    while (cur < numEnd)
    {
        if (*cur == '.') {
            dec = cur;
            break;
        }
        cur++;
    }

    if (!dec) {
        dec = numEnd;
    }
    param->value = 0;
    param->decimals = numEnd - dec;

    cur = numBegin;
    while (cur < dec) {
        uint32_t n = dec - cur - 1;
        param->value += n_pow10(n)*((*cur) - 48);
        cur++;
    }

    cur++;
    while (cur < numEnd) { 
        uint32_t n = cur - dec;
        double t = (*cur) - 48; 
        param->value += t / n_pow10(n); 
        cur++; 
    }


    double scale = n_pow10(param->decimals);
    param->value = round(param->value * scale) / scale;
}



static uint8_t JSON_parse_key(mustache_parser* parser, mustache_param** paramOut, const uint8_t** inputHead, mustache_const_slice key_name, const uint8_t* keyEnd, const uint8_t* sourceEnd, bool deepCopy)
{
    const uint8_t* cur = keyEnd;

    // find next non-whitespace / colon / "
    while (cur < sourceEnd)
    {
        if (!isspace(*cur)) {
            break;
        }
        cur++;
    }
    if (cur >= sourceEnd) {
        return MUSTACHE_ERR_INVALID_JSON;
    }

    mustache_param* lastParam = NULL;
    mustache_param* asGenParam = NULL;
    if (*cur == '"') 
    {
        const uint8_t* strBegin = cur + 1;
        // PARAM IS A STRING
        const uint8_t* strEnd = JSON_get_string_end(strBegin,sourceEnd);
        if (!strEnd) {
            return MUSTACHE_ERR_INVALID_JSON;
        }
        uint32_t strLen = strEnd - strBegin;

        mustache_param_string* param = parser->alloc(parser, sizeof(mustache_param_string));
        if (!param) {
            return MUSTACHE_ERR_ALLOC;
        }
        param->type = MUSTACHE_PARAM_STRING;
        asGenParam = (mustache_param*)param;

        if (strLen > 0) {
            if (deepCopy == true) {
                void* tmpstr = parser->alloc(parser, strLen);
                if (!tmpstr) {
                    return MUSTACHE_ERR_INVALID_JSON;
                }
                memcpy(tmpstr, strBegin, strLen);
                param->str.u = tmpstr;
            }
            else {
                param->str.u = (uint8_t*)strBegin;
            }
        }
        param->str.len = strLen;

        *inputHead = strEnd;
    }
    else if (*cur == '[') {
        // PARAM IS A LIST
        const uint8_t* listClose = JSON_get_list_close(cur, sourceEnd);
        if (!listClose) {
            return MUSTACHE_ERR_INVALID_JSON;
        }

        // CREATE LIST PARAM
        mustache_param_list* param = parser->alloc(parser, sizeof(mustache_param_list));
        if (!param) {
            return MUSTACHE_ERR_ALLOC;
        }
        param->type = MUSTACHE_PARAM_LIST;

        asGenParam = (mustache_param*)param;

        param->valueCount = 0;
        param->pValues = NULL;
        mustache_param* lastChildParam = NULL;

        cur++;
        const uint8_t* beg = NULL;
        // parse all key value pairs in list
        while (cur<listClose)
        {

            if (!(isspace(*cur) || *cur == ',')) {
                beg = cur;
                const uint8_t* end = NULL;
                while (cur < listClose) {
                    if (isspace(*cur) || *cur == ',' || cur == listClose) {
                        end = cur;
                        break;
                    }
                    cur++;
                }
                if (!end) {
                    return MUSTACHE_ERR_INVALID_JSON;
                }

                mustache_param* listChild = NULL;
                uint8_t err = JSON_parse_key(parser, &listChild, &cur, 
                    (mustache_const_slice) { NULL, 0 }, beg, end, true);
                if (err || !listChild) {
                    return MUSTACHE_ERR_INVALID_JSON;
                }

                if (lastChildParam) {
                    lastChildParam->pNext = listChild;
                }
                else {
                    param->pValues = listChild;
                }
                lastChildParam = listChild;
                param->valueCount++;
            }
            cur++;
        }
    }
    else if (*cur == '{') {
        // PARAM IS AN OBJECT
        
    }
    else if (isdigit(*cur)) {
        const uint8_t* numBegin = cur;
        // PARAM IS A NUMBER
        const uint8_t* numEnd = JSON_get_number_end(numBegin,sourceEnd);
        if (!numEnd) {
            return MUSTACHE_ERR_INVALID_JSON;
        }

        mustache_param_number* param = parser->alloc(parser, sizeof(mustache_param_number));
        if (!param) {
            return MUSTACHE_ERR_ALLOC;
        }
        param->type = MUSTACHE_PARAM_NUMBER;

        asGenParam = (mustache_param*)param;

        param->trimZeros = false;
        JSON_number_to_mustache_number(param, numBegin, numEnd);

        *inputHead = numEnd;
    }
    else {
        // PARAM MAY BE BOOLEAN
        const uint8_t* end = get_key_value_end(cur, sourceEnd);
        if (!end) {
            return MUSTACHE_ERR_INVALID_JSON;
        }
        uint32_t len = end - cur;
        bool val;
        // INVALID PARAM OR PARAM IS NULL
        if (len == 4 && strneql(cur, "true", 4)) {
            val = true;
        }
        else if (len == 5 && strneql(cur, "false", 5)) {
            val = false;
        }
        else {
            *inputHead = end;
            return MUSTACHE_SUCCESS;
        }

        mustache_param_boolean* param = parser->alloc(parser, sizeof(mustache_param_boolean));
        if (!param) {
            return MUSTACHE_ERR_ALLOC;
        }
        param->type = MUSTACHE_PARAM_BOOLEAN;
        param->value = val;

        asGenParam = (mustache_param*)param;

        *inputHead = end;
    }

    if (!asGenParam) {
        return MUSTACHE_ERR_ALLOC;
    }

    if (key_name.len > 0) {
        asGenParam->name.u = parser->alloc(parser, key_name.len);
        if (!asGenParam->name.u) {
            return MUSTACHE_ERR_ALLOC;
        }
        memcpy((uint8_t*)asGenParam->name.u, key_name.u, key_name.len);
    }
    else {
        asGenParam->name.u = NULL;
    }
    asGenParam->name.len = key_name.len;
    if (lastParam) {
        lastParam->pNext = asGenParam;
    }
    lastParam = asGenParam;

    *paramOut = asGenParam;

    return MUSTACHE_SUCCESS;
}

static uint8_t JSON_parse_object(mustache_parser* parser, const uint8_t* openingBracket, const uint8_t* sourceEnd, bool deepCopy)
{
    const uint8_t* objClose = JSON_get_object_close(openingBracket, sourceEnd);
    if (!objClose) {
        return MUSTACHE_ERR_INVALID_JSON;
    }

    const uint8_t* cur = openingBracket + 1;
    while (cur < objClose)
    {
        // get key name
        if (*cur == '"') {
            const uint8_t* nameBeg = cur+1;
            const uint8_t* nameEnd = NULL;
            cur = nameBeg+1;
            while (cur <objClose)
            {
                if (*cur == '"') {
                    nameEnd = cur;
                    break;
                }
                cur++;
            }
            if (!nameEnd) {
                return MUSTACHE_ERR_INVALID_JSON;
            }

            const uint8_t* colonEnd=nameEnd+1;
            while (colonEnd < objClose+1) {
                if (*colonEnd == ':') {
                    colonEnd++;
                    break;
                }
                colonEnd++;
            }

            mustache_const_slice keyName = { nameBeg, nameEnd - nameBeg };
            // get value
            mustache_param* param = NULL;
            uint8_t err = JSON_parse_key(parser,&param, &cur, keyName, colonEnd, objClose+1, deepCopy);
            if (err) {
                return err;
            }
        }
        cur++;
    }

    return MUSTACHE_SUCCESS;
}

uint8_t mustache_JSON_to_param_chain(mustache_parser* parser, mustache_const_slice JSON, mustache_param** paramRoot, bool deepCopy)
{
    const uint8_t* jsonBeg = JSON.u;
    const uint8_t* cur = jsonBeg;
    const uint8_t* jsonEnd = JSON.u + JSON.len;

    while (cur < jsonEnd)
    {
        if (*cur == '{') {
            JSON_parse_object(parser, cur, jsonEnd, deepCopy);
        }
        cur++;
    }

    return MUSTACHE_SUCCESS;
}











#ifdef MUSTACHE_SYSTEM_TESTS
#include <stdio.h>

void mustache_print_parameter_list(mustache_param* root)
{

}

#endif // MUSTACHE_SYSTEM_TESTS
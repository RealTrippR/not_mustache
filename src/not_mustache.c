/***************************************************


Robins Free of Charge & Open Source Public License 25

Copyright (C), 2025 - Tripp R. All rights reserved.

Permission for this software, the "software" being source code, binaries, and documentation,
shall hereby be granted, free of charge, to be used for any purpose, including commercial applications,
modification, merging, and redistrubution. The software is provided 'as-is' and comes without any
express or implied warranty. This license is valid under the following restrictions:

1. The origin of the software must not be misrepresentented; the true author(s) of the software
must be attributed as such. This applies every alteration of the "software", the name(s)
of the authors(s) of any alterations must be appended to the list of names of
the author(s) of the preceding version of the software which the alteration is based upon.

2. This license must be included in all redistributions of the software source.

3. All distributions of altered forms of the software must be clearly marked as such.

4. The author(s) of this software and all subsequent alterations hold no responsibility for any
damages that may result from use of the software.

5. The software shall not be used for the purpose of training LLMs ("Large Language Models"),
be included in datasets used for the purpose of training AI, or be used in the advancement of any
form of Artificial Intelligence.

***************************************************/

#include "not_mustache.h"
#include <string.h>
#include <streql/streqlasm.h>
#include <math.h>
#include <stdio.h>

#ifndef NDEBUG
#include <assert.h>
#endif


#if defined(_MSC_VER)
#define alloca(N) _alloca(N)
#else
#define alloca(N) __builtin_alloca(N)
#endif 

#define min(X, Y) ((X) < (Y) ? (X) : (Y))
#define array_count(A) (sizeof(A)/sizeof(A[0]))

typedef enum {
    MUSTACHE_TYPE_VARIABLE,
    MUSTACHE_TYPE_FALSY,
    MUSTACHE_TYPE_POUND,
    MUSTACHE_TYPE_CLOSE,
    MUSTACHE_TYPE_COMMENT
} MUSTACHE_TYPE;

typedef struct {
    mustache_slice buf;
    uint32_t count;
    uint32_t MAX_COUNT;
} parent_stack;

typedef enum
{
    STRUCTURE_TYPE_VAR=0,
    STRUCTURE_TYPE_SCOPED_POUND,
    STRUCTURE_TYPE_SCOPED_CARET,
    STRUCTURE_TYPE_COMMENT,
    STRUCTURE_TYPE_CLOSE,
    STRUCTURE_TYPE_SKIP_RANGE,
    STRUCTURE_TYPE_ROOT,
    STRUCTURE_TYPE_LEN,
    STRUCTURE_TYPE_ELSE,
    STRUCTURE_TYPE_NESTED_TEMPLATE
} STRUCTURE_TYPE;


typedef struct {
    uint32_t lineBegin;
    uint32_t lineEnd;
} standalone_data;

typedef struct structure structure;
typedef struct structure {
    structure* pNext;
    structure* pLast;
    STRUCTURE_TYPE type;

    uint32_t contentsFirst; /*the first byte after the second '{'*/
    uint32_t contentsEnd; /* the first closing '}'*/
    uint32_t precedingMustacheLen;

    mustache_param* param;
    standalone_data* standalone;
} structure;

typedef struct {
    structure* pNext;
    structure* pLast;
    STRUCTURE_TYPE type;

    uint32_t skipFirst;
    uint32_t skipLast;
    uint32_t precedingMustacheLen;

} skip_range_structure;


typedef struct {
    structure* pNext;
    structure* pLast;
    STRUCTURE_TYPE type;

    uint32_t contentsFirst;
    uint32_t contentsEnd;
    uint32_t precedingMustacheLen;

    mustache_param* param;

    uint32_t interiorFirst; /*the first byte of the interior var name*/
    uint32_t interiorEnd; /*the last byte + 1 of the interior (the closing ')') after the name*/
} len_structure;


typedef struct {
    structure* pNext;
    structure* pLast;
    STRUCTURE_TYPE type;

    uint32_t contentsFirst; /*the first byte after the second '{'*/
    uint32_t contentsEnd; /*the first closing '}'*/
    uint32_t precedingMustacheLen;

    mustache_param* param;
    standalone_data* standalone;

    bool escapeHTML;
} var_structure;

typedef struct {
    structure* pNext;
    structure* pLast;
    STRUCTURE_TYPE type;
    uint32_t contentsFirst; /*the first byte after the second '{'*/
    uint32_t contentsEnd; /*the first closing '}'*/

    mustache_param* param;
    standalone_data* standalone;
    uint32_t precedingMustacheLen;

    uint32_t interiorFirst; /*the first byte of the interior*/
    uint32_t interiorEnd; /*the end of the interior - the first opening bracket of it's closing mustache '{{/name}}'*/

    uint32_t curIdx; /*current child index*/
    mustache_param* curChild;

    structure* close_or_else;

    bool wasEvaluated;
    bool renderedLastEvaluation;

} scoped_structure;

typedef struct {
    structure* pNext;
    structure* pLast;
    STRUCTURE_TYPE type;

    uint32_t contentsFirst; /*the first byte after the second '{'*/
    uint32_t contentsEnd; /*the first closing '}'*/
    uint32_t precedingMustacheLen;

    mustache_param* param;
    standalone_data* standalone;

    scoped_structure* parent; /*either of type close or type else*/
} close_structure;

typedef struct {
    structure* pNext;
    structure* pLast;
    STRUCTURE_TYPE type;

    uint32_t contentsFirst; /*the first byte after the second '{'*/
    uint32_t contentsEnd; /*the first closing '}'*/
    uint32_t precedingMustacheLen;

    mustache_param* param;
    uint32_t precedingSpaces;
} nested_template_structure;

typedef struct {
    structure* pNext;
    structure* pLast;
    STRUCTURE_TYPE type;

    uint32_t contentsFirst; /*the first byte after the second '{'*/
    uint32_t contentsEnd; /*the first closing '}'*/
    uint32_t precedingMustacheLen;
    uint32_t interiorBegin;

    standalone_data* standalone;

    scoped_structure* parent;
    close_structure* close;
} else_structure;

#if defined(NOT_MUSTACHE_TARGET_MSVC)
void __chkstk(void);
static void ___chkstk_ms(void) {
    __chkstk();
}
int _isnan(double);
static int __isnan__(double x) {
    return _isnan(x);
}
#else
#define __isnan__(x) isnan(x)
#endif

static size_t no_op_read_cb(void* udata, uint8_t* dst, size_t dstlen) {
    mustache_param_template* tp = (mustache_param_template*)udata;
    return tp->source.len;
}

        
static uint64_t no_op_seek_cb(void* udata, int64_t whence, MUSTACHE_SEEK_DIR seekdir) {
    return 0;
}

void nested_parse_callback(mustache_parser* parser, void* udata, mustache_slice parsed)
{
    uint64_t* len = udata;
    *len = parsed.len;
    return;
}


uint8_t apply_spaces_to_source(uint32_t precedingSpaces, mustache_parser* parser, uint8_t* parsed_begin, uint8_t* parsed_end, mustache_slice outputBuffer, uint64_t* bytesAdded) 
{
    *bytesAdded=0;

    uint8_t* output_end = outputBuffer.u + outputBuffer.len;
    const uint32_t tabs = precedingSpaces / parser->spacesPerTab;
    uint32_t spaces = 0; 
    if (tabs) { spaces = precedingSpaces % parser->spacesPerTab; } else {spaces=precedingSpaces;} /*prevent divide by 0*/
    const uint32_t tabs_spaces_bytes = tabs+spaces;

    uint8_t* cursor = parsed_end-1;
    uint8_t* cur_line_end = cursor;

    uint8_t* expected_end=parsed_begin;
    while (cursor >= parsed_begin-1)
    {
        /*calculate move distance*/
        if ( cursor == parsed_begin-1 || *cursor == '\n' || *cursor == '\r') 
        {
            uint32_t actual_line_len = cur_line_end - (cursor);
            if (cursor == parsed_begin-1) {
                expected_end += actual_line_len;
            } else {
                expected_end += actual_line_len+tabs_spaces_bytes;
            }
            cur_line_end = cursor; 
        }
        cursor--;
    }

    if (expected_end>=output_end) {
        return MUSTACHE_ERR_NO_SPACE; /*BOUNDS CHECK*/
    }

    uint8_t* max_expected_end = expected_end;
    /* start and end, move to beginning */
    cursor = parsed_end-1;
    cur_line_end = cursor;
    while (cursor >= (parsed_begin-1))
    {
        /*calculate move distance*/
        if (cursor == parsed_begin-1 || *cursor == '\n' || *cursor == '\r') 
        {
          
            uint32_t actual_line_len = cur_line_end - (cursor);
            /*WORK BACKWARDS FROM THE EXPECTED END*/
            expected_end -= actual_line_len;
            memcpy(expected_end, cursor+1, actual_line_len);
            if (cursor != parsed_begin-1) {
                expected_end -= tabs_spaces_bytes;

                
                *bytesAdded += tabs_spaces_bytes;
                
                uint32_t i = 0;
                for (i = 0; i < tabs; ++i) {
                    expected_end[i]='\t';
                }
                for (i = tabs; i < tabs+spaces; ++i) {
                    expected_end[i]=' ';
                }
            }

            cur_line_end = cursor; 
        }

        cursor--;
    }

    return MUSTACHE_SUCCESS;
}



int32_t strtoi32(const char* str, uint8_t bufflen, int32_t* strLenOut)
{
    if (strLenOut) /* 0-init */
        *strLenOut = 0;
    int32_t num = 0;
    char negative = 0u;
    if (*str == '-') {
        negative = 1;
        str++;
    }

    const uint8_t max_digits = bufflen;

    int32_t i = 0;
    for (; i < max_digits; ++i)
    {
        if (i == max_digits) {
            if (!(str[i] == '\r' || str[i] == '\n') && !isspace(str[i])) {
                if (strLenOut)
                    *strLenOut = 0;
                return 0;
            }
        }
        else {
            if (str[i] < '0' || str[i] > '9') {
                break;
            }
            else {
                if (negative == 0) {
                    if (num > (INT32_MAX - (str[i] - '0')) / 10) {
                        if (strLenOut)
                            *strLenOut = 0;
                        return 0;
                    }
                }
                else {
                    if (num > (int32_t)(abs(INT32_MIN) - (str[i] - '0')) / 10) {
                        if (strLenOut)
                            *strLenOut = 0;
                        return 0;
                    }
                }
                num = num * 10 + (str[i] - 48);
                if (strLenOut)
                    (*strLenOut)++;
            }
        }
    }
    if (negative)
        num *= -1;
    return num;
}

static int nm_isinf(double x) {
    return x == 1.0 / 0.0 || x == -1.0 / 0.0;
}

static void parent_stack_pop(parent_stack* stack)
{
#ifndef NDEBUG
    if (stack->count == 0) {
        assert(00 && "parent_stack_pop: INVALID CALL, STACK WILL UNDERFLOW!");
    }
#endif

    stack->count--;
}

static uint8_t parent_stack_push(parent_stack* stack, scoped_structure* parent)
{
#ifndef NDEBUG
    if (!(parent->type == STRUCTURE_TYPE_SCOPED_CARET || parent->type == STRUCTURE_TYPE_SCOPED_POUND)) {
        assert(00 && "parent_stack_push: param IS NOT A PARENT.");
    }
    mustache_param* p = parent->param;
    if (!(p->type == MUSTACHE_PARAM_LIST || p->type == MUSTACHE_PARAM_OBJECT)) {
        assert(00 && "parent_stack_push: param IS NOT A PARENT.");
    }
#endif

    if (stack->count == stack->MAX_COUNT) {
        return MUSTACHE_ERR_OVERFLOW;
    }

    uint8_t** pointers = (uint8_t**)stack->buf.u;
    pointers[stack->count] = (uint8_t*)parent;
    stack->count++;

    return MUSTACHE_SUCCESS;
};

/*returns the last structure on the stack.*/
static scoped_structure* parent_stack_last(parent_stack* stack)
{
#ifndef NDEBUG
    if (stack->count == 0) {
        assert(00 && "parent_stack_last: INVALID CALL, stack.count MUST NOT BE EMPTY!");
    }
#endif

    scoped_structure** pointers = (scoped_structure**)stack->buf.u;
    return pointers[stack->count - 1];
}



static uint32_t u32_round_to_next_power_of_2(uint32_t v) {
    v--; /*https://stackoverflow.com/questions/466204/rounding-up-to-next-power-of-2*/
    v |= v >> 1;
    v |= v >> 2;
    v |= v >> 4;
    v |= v >> 8;
    v |= v >> 16;
    v++;
    return v;
}

/* returns the digits in an i64 from a branched lookup table */
static uint8_t digits_i64(int64_t n) {
    if (n<0) {n = n * -1;}
    if (n < 10) return 1;
    if (n < 100) return 2;
    if (n < 1000) return 3;
    if (n < 10000) return 4;
    if (n < 100000) return 5;
    if (n < 1000000) return 6;
    if (n < 10000000) return 7;
    if (n < 100000000) return 8;
    if (n < 1000000000) return 9;
    if (n < 10000000000) return 10;
    if (n < 100000000000) return 11;
    if (n < 1000000000000) return 12;
    if (n < 10000000000000) return 13;
    if (n < 100000000000000) return 14;
    if (n < 1000000000000000) return 15;
    if (n < 10000000000000000) return 16;
    if (n < 100000000000000000) return 17;
    if (n < 1000000000000000000) return 18;
    return 0;
}

/* returns the digits in a u32 from a branched lookup table */
static uint8_t digits_u32(uint32_t n) {
    if (n < 10) return 1;
    if (n < 100) return 2;
    if (n < 1000) return 3;
    if (n < 10000) return 4;
    if (n < 100000) return 5;
    if (n < 1000000) return 6;
    if (n < 10000000) return 7;
    if (n < 100000000) return 8;
    if (n < 1000000000) return 9;
    if (n < 10000000000) return 10;
    if (n < 100000000000) return 11;
    if (n < 1000000000000) return 12;
    if (n < 10000000000000) return 13;
    if (n < 100000000000000) return 14;
    if (n < 1000000000000000) return 15;
    if (n < 10000000000000000) return 16;
    if (n < 100000000000000000) return 17;
    if (n < 1000000000000000000) return 18;
    return 0;
}

/* returns pow(10,n) from a direct lookup table*/
static double n_pow10(uint16_t n) {
    static const double pow10_table[] = {
        1.0,
10.0,
100.0,
1000.0,
10000.0,
100000.0,
1000000.0,
10000000.0,
100000000.0,
1000000000.0,
10000000000.0,
100000000000.0,
1000000000000.0,
10000000000000.0,
100000000000000.0,
1000000000000000.0,
10000000000000000.0,
100000000000000000.0,
1000000000000000000.0,
10000000000000000000.0,
100000000000000000000.0,
1000000000000000000000.0,
10000000000000000000000.0,
100000000000000000000000.0,
1000000000000000000000000.0,
10000000000000000000000000.0,
100000000000000000000000000.0,
1000000000000000000000000000.0,
10000000000000000000000000000.0,
100000000000000000000000000000.0,
1000000000000000000000000000000.0,
10000000000000000000000000000000.0,
100000000000000000000000000000000.0,
1000000000000000000000000000000000.0,
10000000000000000000000000000000000.0,
100000000000000000000000000000000000.0,
1000000000000000000000000000000000000.0,
10000000000000000000000000000000000000.0,
100000000000000000000000000000000000000.0,
1000000000000000000000000000000000000000.0,
10000000000000000000000000000000000000000.0,
100000000000000000000000000000000000000000.0,
1000000000000000000000000000000000000000000.0,
10000000000000000000000000000000000000000000.0,
100000000000000000000000000000000000000000000.0,
1000000000000000000000000000000000000000000000.0,
10000000000000000000000000000000000000000000000.0,
100000000000000000000000000000000000000000000000.0,
1000000000000000000000000000000000000000000000000.0,
10000000000000000000000000000000000000000000000000.0,
100000000000000000000000000000000000000000000000000.0,
1000000000000000000000000000000000000000000000000000.0,
10000000000000000000000000000000000000000000000000000.0,
100000000000000000000000000000000000000000000000000000.0,
1000000000000000000000000000000000000000000000000000000.0,
10000000000000000000000000000000000000000000000000000000.0,
100000000000000000000000000000000000000000000000000000000.0,
1000000000000000000000000000000000000000000000000000000000.0,
10000000000000000000000000000000000000000000000000000000000.0,
100000000000000000000000000000000000000000000000000000000000.0,
1000000000000000000000000000000000000000000000000000000000000.0,
10000000000000000000000000000000000000000000000000000000000000.0,
100000000000000000000000000000000000000000000000000000000000000.0,
1000000000000000000000000000000000000000000000000000000000000000.0,
10000000000000000000000000000000000000000000000000000000000000000.0,
100000000000000000000000000000000000000000000000000000000000000000.0,
1000000000000000000000000000000000000000000000000000000000000000000.0,
10000000000000000000000000000000000000000000000000000000000000000000.0,
100000000000000000000000000000000000000000000000000000000000000000000.0,
1000000000000000000000000000000000000000000000000000000000000000000000.0,
10000000000000000000000000000000000000000000000000000000000000000000000.0,
100000000000000000000000000000000000000000000000000000000000000000000000.0,
1000000000000000000000000000000000000000000000000000000000000000000000000.0,
10000000000000000000000000000000000000000000000000000000000000000000000000.0,
100000000000000000000000000000000000000000000000000000000000000000000000000.0,
1000000000000000000000000000000000000000000000000000000000000000000000000000.0,
10000000000000000000000000000000000000000000000000000000000000000000000000000.0,
100000000000000000000000000000000000000000000000000000000000000000000000000000.0,
1000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
10000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
100000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
1000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
10000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
100000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
1000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
10000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
100000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0,
100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0
    };

    if (n < sizeof(pow10_table) / sizeof(pow10_table[0])) {
        return pow10_table[n];
    }
    return 0;
}

static const uint8_t* get_key_value_end(const uint8_t* start, const uint8_t* sourceEnd)
{
    while (start < sourceEnd)
    {
        if (isspace(*start) || *start == '}') {
            return start;
        }
        start++;
    }
    return sourceEnd;
}

/* converts an i64 to a NON null-terminated ASCII string and returns the number of digits written. */
static int16_t i64toa(int64_t n,uint8_t* buf, size_t size)
{
    int8_t dig = digits_i64(n);
    int16_t i = 0;
    while (n!=0)
    {
        i++;
        buf[dig - i] = n % 10 + 48;
        n /= 10;
    }
    return i;
}

/* returns the expected write length of a dtoa call */
static uint16_t dtoalen(double value, uint16_t precision, bool trimZeros) {
    if (__isnan__(value)) {
        return 3;
    }
    if (nm_isinf(value)) {
        if (value < 0) {
            return 4;
        }
        else {
            return 3;
        }
    }

    if (value < 0) {
        value = -value;
    }

    uint16_t len = 0;
    if (value < 0) {
        len++;
        value = -value;
    }

    long long int_part = (long long)value;
    double frac_part = value - (double)int_part;

    if (int_part == 0) {
        len += 1;
    }
    else {
        long long tmp = int_part;
        while (tmp > 0) {
            len++;
            tmp /= 10;
        }
    }

    if (precision > 0)
    {
        if (!trimZeros)
        {
            len += 1 + precision; 
        }
        else {
            uint16_t frac_len = 0;
            double frac = frac_part;
            uint16_t i;
            for ( i = 0; i < precision; i++) 
            {
                frac *= 10.0;
                int digit = (int)frac;
                frac -= digit;
                if (digit != 0) {
                    frac_len = i + 1;
                }
            }
            if (frac_len > 0) {
                len += 1 + frac_len; /* '.' */
            }
        }
    }

    return len;
}

/* converts a u32 to a string and returns the end of the write position. */
static uint8_t* u32toa(uint32_t value, uint8_t* buf, size_t bufsize)
{
    uint8_t digits = digits_u32(value);
    uint8_t* bufEnd = buf + bufsize - 1;
    uint8_t i = 0;
    while (value && buf < bufEnd)
    {
        uint8_t* pos = buf + digits - i - 1;
        if (pos<bufEnd) {
            *pos = value % 10 + '0';
        }
        value /= 10;
        i++;
    }
    return buf+i;
}

/* converts a double to string and returns the updated write head */
static uint8_t* dtoa(double value, uint8_t* buf, size_t size, uint16_t precision, bool trimZeros) {
    if (size == 0) return buf;

    if (__isnan__(value)) {
        memcpy(buf, "nan", min(size, 3));
        return buf + min(size, 3);
    }
    if (nm_isinf(value)) {
        if (value < 0) {
            memcpy(buf, "-inf", min(size, 4));
            return buf + min(size, 4);
        }
        else {
            memcpy(buf, "inf", min(size, 3));
            return buf + min(size, 3);
        }
    }

    char* start = buf;

    if (value < 0) {
        if (size <= 1) return buf;
        *buf++ = '-';
        size--;
        value = -value;
    }

    /* get integer and frac parts */
    long long int_part = (long long)value;
    double frac_part = value - (double)int_part;

    /* Write integer part */
    int written = i64toa(int_part, buf, size);
    if (written < 0 || written >= (int)size) return buf;

    buf += written;
    size -= written;

    char frac_buf[64];
    uint8_t frac_len = 0;

    frac_part += 0.5 * pow(10, -precision);

    int32_t i;
    for ( i = 0; i < precision && frac_len + 1 < (int32_t)sizeof(frac_buf); i++) {
        frac_part *= 10.0;
        int32_t digit = (int32_t)frac_part;
        frac_buf[frac_len++] = '0' + digit;
        frac_part -= digit;
    }

    if (trimZeros) {
        while (frac_len > 0 && frac_buf[frac_len - 1] == '0')
            frac_len--;
    }

    /* skip '.' if no frac. digits remain */
    if (frac_len == 0)
        return buf;

    /* '.' */
    if (size < 2) return buf;
    *buf++ = '.';
    size--;

    /* write fractional digits */
    uint8_t i_8;
    for ( i_8= 0; i_8 < frac_len && size > 1; i_8++) {
        *buf++ = frac_buf[i_8];
        size--;
    }

    return buf;
}


static uint64_t fseek_callback(void* udata, int64_t whence, MUSTACHE_SEEK_DIR seekdir)
{
    FILE* fptr = (FILE*)udata;

    if (seekdir == MUSTACHE_SEEK_LEN) {
        _fseeki64(fptr, 0, SEEK_END);
        uint64_t s = _ftelli64(fptr);
        rewind(fptr);
        return s;
    }
    return _fseeki64(fptr, whence, seekdir);
}

static size_t fread_callback(void* udata, uint8_t* dst, size_t dstlen)
{
    FILE* fptr = (FILE*)udata;
    return fread(dst, 1, dstlen, fptr);
}




static scoped_structure* get_scoped_else_parent(const structure* close, const uint8_t* interiorFirst, const uint8_t* sourceBegin)
{
    const uint8_t* cur = interiorFirst;
    uint32_t depth = 1;
    const uint8_t* blockEnd=NULL;
    while (cur >= sourceBegin + 1) {
        const uint8_t* blockBegin = NULL;
        if (*cur == '}' && *(cur - 1) == '}') {
            blockBegin = blockEnd;
        }

        if (*cur == '{' && *(cur - 1) == '{' && *(cur - 2) != '/') {
            if (*(cur + 1) == '#' || *(cur + 1) == '^') {
                depth--;
                if (depth == 0) {
                    uint32_t sourceOffset = cur - sourceBegin + 1;
                    /* GET PARAMETER */
                    const structure* curStr = (const structure*)close;
                    curStr = curStr->pLast;
                    while (curStr)
                    {
                        if (curStr->contentsFirst == sourceOffset) {
                            return (scoped_structure*)curStr;
                        }
                        curStr = curStr->pLast;
                    }
                    return NULL;
                }
            }
            else if (*(cur + 1) == '/') {
                depth++;
                cur -= 1;
            }

            blockEnd = NULL;
            blockBegin = NULL;
        }
        cur--;
    }

    return NULL;
}
static scoped_structure* get_scoped_close_parent(const structure* close, const uint8_t* interiorFirst, const uint8_t* sourceBegin)
{
    const uint8_t* cur = interiorFirst;
    uint32_t depth = 0;
    while (cur >= sourceBegin + 1) {
        const uint8_t* blockBegin = NULL;
        if (*cur == '{' && *(cur - 1) == '{' && *(cur - 2) != '/') {
            if (*(cur + 1) == '#' || *(cur + 1) == '^' || strneql(cur+1,"else",4)) {
                depth--;
                if (depth == 0) {
                    uint32_t sourceOffset = cur - sourceBegin + 1;
                    /* GET PARAMETER */
                    const structure* curStr = (const structure*)close;
                    curStr = curStr->pLast;
                    while (curStr)
                    {
                        if (curStr->contentsFirst == sourceOffset) {
                            return (scoped_structure*)curStr;
                        }
                        curStr = curStr->pLast;
                    }
                    return NULL;
                }
            }
            else if (*(cur + 1) == '/') {
                depth++;
                cur -= 1;
            }
            blockBegin = cur;
        }
        cur--;
    }

    return NULL;
}

static uint8_t* get_truthy_close(mustache_const_slice paramName, uint8_t* cur, uint8_t* end)
{
#ifndef NDEBUG
    if (cur == NULL || end < cur || end == NULL)
    {
        assert(00 && "get_truthy_close: INVALID CUR OR END ARGUMENT");
    }
#endif

    while (cur < end-2)
    {
        if (*cur == '{' && *(cur + 1) == '{' && *(cur + 2) == '/')
        {
            /* find end */
            cur += 3;

            uint8_t* cur2 = cur;
            while (cur2<end-1)
            {
                if (*cur2 == '}' && *(cur2 + 1) == '}')
                {
                    break;
                }
                cur2++;
            }

          
            uint16_t dist = cur2 - cur;
            if (paramName.len == dist && strneql(paramName.u, cur, dist))
            {
                return cur-3;
            }
        }
        cur++;
    }
    return NULL;
}

static uint8_t* get_line_end(uint8_t* line, uint8_t* searchEnd)
{
    while (line<searchEnd)
    {
        if (*line == '\n') {
            return line;
        }
        line++;
    }
    return line;
}

static uint8_t* get_line_begin(uint8_t* line, uint8_t* searchBegin) {
    while (line!=searchBegin)
    {
        if (*line == '\n') {
            line++;
            break;
        }
        line--;
    }
    return line;
}

static MUSTACHE_TYPE get_mustache_type(uint8_t* mustacheOpen) {
    switch (*mustacheOpen)
    {
    case '!':
        return MUSTACHE_TYPE_COMMENT;
    case '^':
        return MUSTACHE_TYPE_FALSY;
    case '#':
        return MUSTACHE_TYPE_POUND;
    case '/':
        return MUSTACHE_TYPE_CLOSE;
    default:
        return MUSTACHE_TYPE_VARIABLE;
    }
}
static bool is_line_standalone(uint8_t* line, uint8_t* lineEnd)
{
    bool isInMustache = false;
    while (line < lineEnd)
    {
        if (line < lineEnd - 2) {
            if (*line == '{' && *(line + 1) == '{')
            {
                uint8_t prefix = *(line + 2);
                if (!(prefix == '#' || prefix == '^' || prefix == '!' || prefix == '/')
                    && !(lineEnd - line+2) >=4 && strneql(line+2, "else",4))
                {
                    return false;
                }
                isInMustache = true;
            }
            if (*(line + 1) == '}' && *(line + 2) == '}')
            {
                isInMustache = false;
                line += 3;
                if (line >= lineEnd) {
                    return true;
                }
            }
        }
        if (!isInMustache && !isspace(*line)) {
            return false;
        }
        line++;
    }
    return true;
}

static bool is_mustache_open(uint8_t* s) {
#ifndef NDEBUG
    if (s == NULL) {
        assert(00 && "is_mustache_open: s MUST NOT BE A VALID POINTER.");
    }
#endif
    if (*s == '{' && *(s + 1) == '{') {
        return true;
    }
    return false;
}

static bool is_mustache_close(uint8_t* s) {
#ifndef NDEBUG
    if (s == NULL) {
        assert(00 && "is_mustache_open: s MUST NOT BE A VALID POINTER.");
    }
#endif
    if (*s == '}' && *(s + 1) == '}') {
        return true;
    }
    return false;
}

static mustache_param_template* get_nested_template_param(const uint8_t* nameBegin, const uint8_t* nameEnd, mustache_param* globalParams) 
{
    uint16_t nameLen = nameEnd - nameBegin;
    /* TRAVERSE GLOBAL PARAMS */
    while (globalParams) {
        if (globalParams->type == MUSTACHE_PARAM_TEMPLATE && globalParams->name.len == nameLen &&
            strneql(globalParams->name.u, nameBegin, nameLen))
        {
            return (mustache_param_template*)globalParams;
        }

        globalParams = globalParams->pNext;
    }

    return NULL;
}


static mustache_param* get_parameter(const uint8_t* nameBegin, const uint8_t* nameEnd, mustache_param* globalParams, parent_stack* parentStack)
{
    /* TRAVERSE PARENT STACK */
    uint16_t nameLen = nameEnd - nameBegin;
    int32_t i;
    for (i = parentStack->count-1; i >= 0; i--) {
        scoped_structure* structNode = ((scoped_structure**)parentStack->buf.u)[i];
        mustache_param* parentNode = structNode->param;

        mustache_param* node;
        uint32_t MAX_COUNT;

        if (parentNode->type == MUSTACHE_PARAM_LIST) {
            mustache_param_list* list = (mustache_param_list*)parentNode;
            MAX_COUNT = list->valueCount;
            node = list->pValues;
        }
        else if (parentNode->type == MUSTACHE_PARAM_OBJECT) {
            mustache_param_object* obj = (mustache_param_object*)parentNode;
            node = obj->pMembers;
            MAX_COUNT = UINT32_MAX;
        }
        else {
#ifndef NDEBUG
            assert(00 && "get_parameter: PARENT STACK IS CORRUPTED.");
#endif
            return NULL;
        }




        uint32_t c = 0;
        while (node&&c<MAX_COUNT)
        {
            if (node->name.len == nameLen &&
                strneql(node->name.u, nameBegin, nameLen))
            {
                return node;
            }
            node = node->pNext;
            c++;
        }
    }

    /* TRAVERSE GLOBAL PARAMS */
    while (globalParams) {
        if (globalParams->name.len == nameLen &&
            strneql(globalParams->name.u, nameBegin, nameLen))
        {
            return globalParams;
        }

        globalParams = globalParams->pNext;
    }

    return NULL;
}

static mustache_param* get_child_param(uint8_t* nameBegin, uint8_t nameLen, mustache_param* parent)
{

    mustache_param* node;
    uint32_t MAX_COUNT;

    if (parent->type == MUSTACHE_PARAM_LIST) {
        mustache_param_list* list = (mustache_param_list*)parent;
        MAX_COUNT = list->valueCount;
        node = list->pValues;
    }
    else if (parent->type == MUSTACHE_PARAM_OBJECT) {
        mustache_param_object* obj = (mustache_param_object*)obj;
        node = obj->pMembers;
        MAX_COUNT = UINT32_MAX;
    }
    else {
#ifndef NDEBUG
        assert(00 && "get_child_param: parent IS NOT A PARENT.");
#endif
    }

    uint32_t ni = 0;
    while (node && ni < MAX_COUNT)
    {
        if (node->name.len == nameLen && strneql(node->name.u, nameBegin, nameLen)) {
            return node;
        }
        node = node->pNext;
        ni++;
    }
    return NULL;
}

static uint8_t* write_variable(mustache_param* paramBASE, uint8_t* outputHead, uint8_t* outputEnd, bool escapeHTML)
{
    if (paramBASE->type == MUSTACHE_PARAM_NUMBER) {
        mustache_param_number* param = (mustache_param_number*)paramBASE;
        outputHead = dtoa(param->value, outputHead, (size_t)(outputEnd - outputHead),
            param->decimals, param->trimZeros);
    }
    else if (paramBASE->type == MUSTACHE_PARAM_BOOLEAN) {
        mustache_param_boolean* param = (mustache_param_boolean*)paramBASE;
        if (param->value) {
            uint8_t dist = min((int8_t)strlen("true"), outputEnd - outputHead);
            memcpy(outputHead, "true", dist);
            outputHead += dist;
        }
        else {
            uint8_t dist = min((int8_t)strlen("false"), outputEnd - outputHead);
            memcpy(outputHead, "false", dist);
            outputHead += dist;
        }
    }
    else if (paramBASE->type == MUSTACHE_PARAM_STRING) {
        mustache_param_string* param = (mustache_param_string*)paramBASE;

        uint32_t distToEnd = outputEnd - outputHead;

        if (escapeHTML) {
            /*
                '&': '&amp;',
                '<': '&lt;',
                '>': '&gt;',
                '"': '&quot;',
                "'": '&#039;'
            */
            uint8_t* cur = param->str.u;
            uint8_t* end = param->str.u + param->str.len;
            while (cur<end && outputHead < outputEnd)
            {
                if (*cur == '&') {
                    uint8_t dist = min(outputEnd - outputHead, strlen("&amp;"));
                    memcpy(outputHead, "&amp;", dist);
                    outputHead += dist;
                }
                else if (*cur == '<') {
                    uint8_t dist = min(outputEnd - outputHead, strlen("&lt;"));
                    memcpy(outputHead, "&lt;", dist);
                    outputHead += dist;
                }
                else if (*cur == '>') {
                    uint8_t dist = min(outputEnd - outputHead, strlen("&gt;"));
                    memcpy(outputHead, "&gt;", dist);
                    outputHead += dist;
                }
                else if (*cur == '"') {
                    uint8_t dist = min(outputEnd - outputHead, strlen("&quot;"));
                    memcpy(outputHead, "&quot;", dist);
                    outputHead += dist;
                }
                else if (*cur == '\'') {
                    uint8_t dist = min(outputEnd - outputHead, strlen("&#039;"));
                    memcpy(outputHead, "&#039;", dist);
                    outputHead += dist;
                }
                else {
                    *outputHead = *cur;
                    outputHead++;
                }
                cur++;
            }
        }
        else {
            uint32_t dist = min(distToEnd, param->str.len);
            memcpy(outputHead, param->str.u, dist);
            outputHead += dist;
        }
    }
   
    return outputHead;
}

static uint8_t is_parent(mustache_param* param) {
    if (param->type == MUSTACHE_PARAM_LIST || param->type == MUSTACHE_PARAM_OBJECT) {
        return true;
    }
    return false;
}


static uint8_t* get_mustache_close(uint8_t* inputHead, uint8_t* inputEnd) {
    while (inputHead < inputEnd)
    {
        if (is_mustache_close(inputHead)) {
            return inputHead;
        }
        inputHead++;
    }
    return NULL;
}

static uint8_t* get_scoped_interior_end(uint8_t* interiorFirst, uint8_t* end)
{
    uint32_t no = 1;
    while (interiorFirst <end)
    {
        uint8_t prefix = *(interiorFirst + 2);
        if (is_mustache_open(interiorFirst) && (prefix=='#' || prefix=='^')) {
            no++;
            interiorFirst += 2;
        }
        else if (is_mustache_open(interiorFirst) && prefix=='/') {
            no--;
            if (no == 0) {
                return interiorFirst;
            }
        }

        interiorFirst++;
    }
    return NULL;
}

static bool is_truthy(mustache_param* p)
{
    if (p == NULL) {
        return false;
    }
    if (p->type == MUSTACHE_PARAM_STRING) {
        mustache_param_string* param = (mustache_param_string*)p;
        if (param->str.len > 0) {
            return true;
        } else {
            return false;
        }
    }
    else if (p->type == MUSTACHE_PARAM_BOOLEAN) {
        mustache_param_boolean* param = (mustache_param_boolean*)p;
        return param->value;
    }
    else if (p->type == MUSTACHE_PARAM_NUMBER) {
        mustache_param_number* param = (mustache_param_number*)p;
        return (bool)param->value;
    }
    else if (p->type == MUSTACHE_PARAM_LIST) {
        mustache_param_list* param = (mustache_param_list*)p;
        return param->valueCount;
    }
    if (p) {
        return true;
    }
    return false;
}

static uint8_t source_to_structured(mustache_parser* parser, structure* structureRoot, uint8_t* inputFirst, uint8_t* inputHead, uint8_t* inputEnd)
{
    structure* last_struct = structureRoot;
    while (inputHead<inputEnd)
    {
        if (is_mustache_open(inputHead))
        {
            uint8_t precedingStacheLen=2;
            uint8_t* first = inputHead+2;
            uint8_t* end = get_mustache_close(first, inputEnd);
            structure* mstruct = NULL;


            /* handle escape case */
            if (*(inputHead-1)=='/') {
                mstruct = parser->alloc(parser, sizeof(skip_range_structure));
                if (!mstruct) { return MUSTACHE_ERR_ALLOC; }
                mstruct->type = STRUCTURE_TYPE_SKIP_RANGE;
                mstruct->pNext = NULL;

                skip_range_structure* asSkip = (skip_range_structure*)mstruct;
                asSkip->skipFirst = (inputHead - inputFirst)-1;
                asSkip->skipLast = inputHead - inputFirst;

                inputHead = end+2;
            }
            /* handle else case */
            else if (end - first == 4 && strneql(first, "else", 4)) {
                int i = 0;
                mstruct = parser->alloc(parser, sizeof(else_structure));
                if (!mstruct) { return MUSTACHE_ERR_ALLOC; }
                mstruct->type = STRUCTURE_TYPE_ELSE;

                else_structure* asElse = (else_structure*)mstruct;
                mstruct->param = NULL;
                mstruct->pNext = NULL;
                mstruct->pLast = last_struct;
                mstruct->standalone = NULL;
                asElse->close = NULL;
                asElse->parent = get_scoped_else_parent(mstruct, first, inputFirst);
                if (!asElse->parent) {
                    parser->free(parser, mstruct);
                    return MUSTACHE_ERR_INVALID_TEMPLATE;
                }
                if (!asElse->parent->close_or_else) {
                    asElse->parent->close_or_else = mstruct;
                }

                mstruct->contentsFirst = first - inputFirst;
                mstruct->contentsEnd = end - inputFirst;

                /* check if it's standalone */
                bool standlone = false;
                uint8_t* lineEnd;
                /* check if the starting cond. line is standalone. If so, skip it. */
                uint8_t* lineBeg = get_line_begin(first, inputFirst);
                lineEnd = get_line_end(first, inputEnd);
                if (lineEnd) {
                    standlone = is_line_standalone(lineBeg, lineEnd);
                    if (standlone) {
                        mstruct->standalone = parser->alloc(parser, sizeof(standalone_data));
                        if (!mstruct->standalone) {
                            parser->free(parser, mstruct);
                            return MUSTACHE_ERR_ALLOC;
                        }
                        mstruct->standalone->lineBegin = lineBeg - inputFirst;
                        mstruct->standalone->lineEnd = lineEnd - inputFirst;

                        asElse->interiorBegin = lineEnd - inputFirst;
                    }
                    else {
                        mstruct->standalone = NULL;
                        asElse->interiorBegin = asElse->contentsEnd + strlen("}}");
                    }
                }
                else {
                    asElse->interiorBegin = asElse->contentsEnd + strlen("}}");;
                }

                inputHead = end + 2;
            }
            /* handle len case */
            else if (end-first>=4 && strneql(first, "len(",4))
            { 
                if (inputHead + 4 >= inputEnd) {
                    return MUSTACHE_ERR_INVALID_TEMPLATE;
                }
                uint8_t* interiorFirst = first + 4;
                uint8_t* interiorEnd=NULL;
                inputHead = interiorFirst;
                /* get closing ')' */
                while (inputHead < inputEnd)
                {
                    if (*inputHead == ')') {
                        interiorEnd = inputHead;
                        break;
                    }
                    inputHead++;
                }
                if (!interiorEnd) {
                    return MUSTACHE_ERR_INVALID_TEMPLATE;
                }
                mstruct = parser->alloc(parser, sizeof(len_structure));
                if (!mstruct) { return MUSTACHE_ERR_ALLOC; }
                mstruct->type = STRUCTURE_TYPE_LEN;
                mstruct->pNext = NULL;

                len_structure* asLen = (len_structure*)mstruct;
                asLen->param = NULL;
                asLen->interiorFirst = (interiorFirst - inputFirst);
                asLen->interiorEnd = interiorEnd - inputFirst;

                inputHead = end + 2;
            }
            /* handle comments and closures */
            else if (*first == '/' || *first == '!')
            {
                if (*first == '/') {
                    mstruct = parser->alloc(parser, sizeof(close_structure));
                    if (!mstruct) {
                        return MUSTACHE_ERR_ALLOC;
                    }
                    mstruct->type = STRUCTURE_TYPE_CLOSE;
                    close_structure* asClosed = (close_structure*)mstruct;
                    asClosed->pLast = last_struct;
                    asClosed->parent = get_scoped_close_parent(mstruct,first, inputFirst);
                    if (!asClosed->parent) {
                        parser->free(parser, mstruct);
                        return MUSTACHE_ERR_INVALID_TEMPLATE;
                    }
                    if (asClosed->parent->type == STRUCTURE_TYPE_ELSE) {
                        else_structure* asElse = (else_structure*)asClosed->parent;
                        if (!asElse->close) {
                            asElse->close = asClosed;
                        }
                    }
                    else {
                        if (!asClosed->parent->close_or_else) {
                            asClosed->parent->close_or_else = (structure*)asClosed;
                        }
                    }
                }
                else {
                    mstruct = parser->alloc(parser, sizeof(structure));
                    if (!mstruct) {
                        return MUSTACHE_ERR_ALLOC;
                    }
                    mstruct->type = STRUCTURE_TYPE_COMMENT;
                }
                mstruct->param = NULL;
                mstruct->pNext = NULL;
           
                /* check if it's standalone */
                bool standlone = false;
                uint8_t* lineEnd;
                /* check if the starting cond. line is standalone. If so, skip it. */
                uint8_t* lineBeg = get_line_begin(first, inputFirst);
                lineEnd = get_line_end(first, inputEnd);
                if (lineEnd) {
                    standlone = is_line_standalone(lineBeg, lineEnd);
                    if (standlone) {
                      
                        mstruct->standalone = parser->alloc(parser,sizeof(standalone_data));
                        if (!mstruct->standalone) {
                            return MUSTACHE_ERR_ALLOC;
                        }
                        mstruct->standalone->lineBegin = lineBeg - inputFirst;
                        mstruct->standalone->lineEnd = lineEnd - inputFirst;
                    }
                    else {
                        mstruct->standalone = NULL;
                    }
                }
                else {
                    mstruct->standalone = NULL;
                }
            }
            else if (*first == '^' || *first == '#')
            {
                mstruct = parser->alloc(parser, sizeof(scoped_structure));
                if (!mstruct) {
                    return MUSTACHE_ERR_ALLOC;
                }

                mstruct->param = NULL;
                mstruct->pNext = NULL;

                if (*first == '^') {
                    mstruct->type = STRUCTURE_TYPE_SCOPED_CARET;
                }
                else {
                    mstruct->type = STRUCTURE_TYPE_SCOPED_POUND;
                }

                /* check if it's standalone */
                bool standlone = false;
                uint8_t* lineEnd;
                /* check if the starting cond. line is standalone. If so, skip it. */
                uint8_t* lineBeg = get_line_begin(first, inputFirst);
                lineEnd = get_line_end(first, inputEnd);
                if (lineEnd) {
                    standlone = is_line_standalone(lineBeg, lineEnd);
                    if (standlone) {

                        mstruct->standalone = parser->alloc(parser, sizeof(standalone_data));
                        if (!mstruct->standalone) {
                            return MUSTACHE_ERR_ALLOC;
                        }
                        mstruct->standalone->lineBegin = lineBeg - inputFirst;
                        mstruct->standalone->lineEnd = lineEnd - inputFirst;
                    }
                    else {
                        mstruct->standalone = NULL;
                    }
                }
                else {
                    mstruct->standalone = NULL;
                }

                scoped_structure* asScoped = (scoped_structure*)mstruct;
                asScoped->interiorFirst = end - inputFirst + 2;
                uint8_t* int_end = get_scoped_interior_end(end+2,inputEnd);
                if (!int_end) {
                    asScoped->interiorEnd = 0;
                    parser->free(parser, mstruct);
                    return MUSTACHE_ERR_INVALID_TEMPLATE;
                }
                asScoped->interiorEnd = int_end - inputFirst;
                asScoped->close_or_else = NULL;
                asScoped->wasEvaluated = false;
            }
            /* handle nested templates */
            else if (*first == '>') {
                mstruct = parser->alloc(parser, sizeof(nested_template_structure));
                if (!mstruct) {
                    return MUSTACHE_ERR_ALLOC;
                }
                mstruct->param = NULL;
                mstruct->pNext = NULL;
                mstruct->type = STRUCTURE_TYPE_NESTED_TEMPLATE;
                
                nested_template_structure* asTemplate = (nested_template_structure*)mstruct;
                precedingStacheLen = 3;
                asTemplate->precedingSpaces = 0;


                uint8_t* cursor = get_line_begin(first, inputFirst);

                /* handle propagating spaces */
                if (cursor && cursor < first-2 && *(first+1) == '>') 
                {
                    precedingStacheLen = 4;
                    /* get preceding spaces */
                    while (cursor < end)
                    {
                        if (*cursor == ' ') {
                            asTemplate->precedingSpaces++;
                        }
                        else if (*cursor == '\t') {
                            asTemplate->precedingSpaces+=parser->spacesPerTab;
                        }
                        else {
                            break;
                        }
                        cursor++;
                    }
                }
            }
            else {
                mstruct = parser->alloc(parser, sizeof(var_structure));
                if (!mstruct) {
                    return MUSTACHE_ERR_ALLOC;
                }
                mstruct->param = NULL;
                mstruct->pNext = NULL;
                mstruct->type = STRUCTURE_TYPE_VAR;

                var_structure* asVar = (var_structure*)mstruct;

                if (*first == '&') {
                    first++;
                    asVar->escapeHTML = false;
                    precedingStacheLen = 3;
                } else {
                    asVar->escapeHTML = true;
                }
            }

            if (mstruct->type != STRUCTURE_TYPE_SKIP_RANGE) {
                mstruct->contentsFirst = first - inputFirst;
                mstruct->contentsEnd = end - inputFirst;
            }
            inputHead = end + 1;

            last_struct->pNext = mstruct;
            mstruct->pLast = last_struct;
            mstruct->precedingMustacheLen = precedingStacheLen;
            last_struct = mstruct;
        }
        
        inputHead++;
    }
    
    return MUSTACHE_SUCCESS;
}


static uint8_t* mwrite(uint8_t* outputHead, uint8_t* outputEnd, const uint8_t* sourceBeg, const uint8_t* sourceEnd)
{
    if (sourceBeg > sourceEnd) {
        return outputHead;
    }
    
    size_t a = sourceEnd - sourceBeg;
    size_t b = outputEnd - outputHead;
    size_t s = min((sourceEnd- sourceBeg), (outputEnd- outputHead));
    memcpy(outputHead, sourceBeg, s);
    return outputHead+s;
}


void eval_jump(structure* mstruct, const uint8_t* m_name_first, const uint8_t* m_name_end, const uint8_t* input, uint8_t* outputEnd, uint8_t** outputHead, const uint8_t** lastNonEscaped) {
    if (mstruct->standalone) {
        const uint8_t* t = input + mstruct->standalone->lineBegin;
        if (t > *lastNonEscaped) {
            *outputHead = mwrite(*outputHead, outputEnd, *lastNonEscaped, t);
        }
        *lastNonEscaped = input + mstruct->standalone->lineEnd + 1;
    }
    else {
        const uint8_t* t = m_name_first - 3;
        if (t > *lastNonEscaped) {
            *outputHead = mwrite(*outputHead, outputEnd, *lastNonEscaped, t);
        }
        *lastNonEscaped = m_name_end + strlen("{{");
    }
}

static uint32_t get_parent_child_count(mustache_param* parent)
{
#ifndef NDEBUG
    if (parent->type != MUSTACHE_PARAM_OBJECT && parent->type != MUSTACHE_PARAM_LIST) {
        assert(00 && "get_parent_child_count: parent IS NOT A VALID PARENT.");
    }
#endif
    if (parent->type == MUSTACHE_PARAM_LIST) {
        mustache_param_list* asList = (mustache_param_list*)parent;
        return asList->valueCount;
    }
    else {
        uint32_t c = 0;
        while (parent)
        {
            c++;
            parent = parent->pNext;
        }
        return c;
    }
}

static mustache_param* get_nth_child(mustache_param* parent, int32_t idx) 
{
#ifndef NDEBUG
    if (parent->type != MUSTACHE_PARAM_OBJECT && parent->type != MUSTACHE_PARAM_LIST) {
        assert(00 && "get_nth_child: parent IS NOT A VALID PARENT.");
    }
#endif
    uint32_t childCount = get_parent_child_count(parent);
    if (idx < 0) {
        idx = childCount +idx;
    }

    uint32_t i = 0;
    mustache_param* child = ((mustache_param_object*)parent)->pMembers;
    while (i!=idx && child && i < childCount)
    {
        i++;
        child = child->pNext;
    }
    return child;
}


static mustache_param* resolve_param_member(mustache_param* root, const uint8_t* strFirst, const uint8_t* strEnd)
{
#ifndef NDEBUG
    if (*strFirst != '.' && *strFirst != '[') {
        assert(00 && "resolve_param_member: strFirst must be a string parameter chain, i.e. '.member.name'");
    }
#endif 

    if (strFirst+1 == strEnd) {
        return root;
    }

    const uint8_t* cur = strFirst;

    mustache_param* param = root;
    const uint8_t* lastDot = NULL;
    while (cur <= strEnd)
    {
        if (*cur == '[') {
            const uint8_t* intFirst = cur+1;
            while (*cur != ']' || cur == strEnd) {
                cur++;
            }
            /* resolve member */
            const uint8_t* intEnd = cur;

            int32_t index = strtoi32(intFirst, intEnd - intFirst, NULL);
            mustache_param* child = get_nth_child(root, index);
            if (!child)
                return NULL;
            param = child;
        }
        else if (*cur == '.' || cur == strEnd)
        {    
            if (lastDot) {

                const uint8_t* nameBegin = lastDot + 1;
                const uint8_t* nameEnd = cur;
                uint32_t nameLen = nameEnd - nameBegin;

                uint32_t i;
                if (param->type == MUSTACHE_PARAM_LIST) {
                    mustache_param_list* asList = (mustache_param_list*)param;
                    i = asList->valueCount;
                }
                else {
                    i = UINT32_MAX;
                }

                param = ((mustache_param_list*)param)->pValues;
                while (param && i > 0)
                {
                    if (nameLen == param->name.len && strneql(nameBegin, param->name.u, nameLen)) {
                        break;
                    }
                    param = param->pNext;
                    i--;
                }

                if (!param) {
                    return NULL;
                }
            }
            lastDot = cur;
        }
        cur++;
    }

    return param;
}

uint8_t write_structured(mustache_slice outputBuffer, uint8_t** oh, mustache_const_slice inputBuffer, uint8_t* inputEnd, structure* structureRoot, 
                         mustache_param* globalParams, parent_stack* parentStack, mustache_parser* parser)
{
    structure* mstruct = structureRoot->pNext; /* SKIP ROOT */

    /* INPUT */
    const uint8_t* inputHead = inputBuffer.u;
    const uint8_t* input=inputBuffer.u;

    /* OUTPUT */
    uint8_t* outputHead = outputBuffer.u;
    uint8_t* outputEnd = outputBuffer.u + outputBuffer.len;

    const uint8_t* lastNonEscaped = inputHead;
    while (mstruct)
    {
        if (mstruct->type == STRUCTURE_TYPE_SKIP_RANGE) {
            skip_range_structure* asSkipRange = (skip_range_structure*)mstruct;
            const uint8_t* t = input + asSkipRange->skipFirst;
            inputHead = t;
            outputHead = mwrite(outputHead, outputEnd, lastNonEscaped, inputHead);
            t = input + asSkipRange->skipLast;
            lastNonEscaped = t;
        }
        else if (mstruct->type == STRUCTURE_TYPE_LEN)
        {
            const uint8_t* m_len_str_first = input + mstruct->contentsFirst;
            const uint8_t* m_len_str_end = input + mstruct->contentsEnd;

            len_structure* asLen = (len_structure*)mstruct;
            const uint8_t* int_begin = input + asLen->interiorFirst;
            const uint8_t* int_end = input + asLen->interiorEnd;


            outputHead = mwrite(outputHead, outputEnd, lastNonEscaped, m_len_str_first - mstruct->precedingMustacheLen);


            if (!asLen->param) {
                mstruct->param = get_parameter(int_begin, int_end, globalParams, parentStack);
            }
            if (asLen->param) {
                uint32_t cc = get_parent_child_count(mstruct->param);
                outputHead = u32toa(cc, outputHead, (size_t)(outputEnd - outputHead));
                lastNonEscaped = m_len_str_end + strlen("}}");
            }
        }
        else if (mstruct->type == STRUCTURE_TYPE_NESTED_TEMPLATE) {
            
            nested_template_structure* asTemplate = (nested_template_structure*)mstruct;
            const uint8_t* m_name_first = input + mstruct->contentsFirst+(asTemplate->precedingMustacheLen-2);
            const uint8_t* m_name_end = input + mstruct->contentsEnd;

            outputHead = mwrite(outputHead, outputEnd, lastNonEscaped, m_name_first - mstruct->precedingMustacheLen);
            lastNonEscaped = m_name_end + strlen("}}");

            if (!asTemplate->param) {
                mstruct->param = (mustache_param*)get_nested_template_param(m_name_first, m_name_end, globalParams);
                if (!mstruct->param) {
                    goto skip_node;
                }
            }

            
            mustache_param_template* template_param = (mustache_param_template*)mstruct->param;
            

            mustache_stream dummy_stream = {
                .readCallback = no_op_read_cb,
                .seekCallback = no_op_seek_cb,
                .udata=template_param
            };

            mustache_slice input_slice = {(uint8_t*)template_param->source.u, template_param->source.len};
            mustache_slice output_slice = {outputHead, outputEnd-outputHead};
            uint64_t bytesWritten=0;




            uint8_t err = mustache_parse_stream(parser, template_param->parentStackBuffer, &dummy_stream, template_param->structure, template_param->parameters, input_slice, output_slice, &bytesWritten, nested_parse_callback);
            if (err!=MUSTACHE_SUCCESS) {
                goto skip_node;
            }

            uint8_t* parsed_begin = outputHead;
            outputHead+=bytesWritten;
            uint8_t* parsed_end = outputHead;

            if (asTemplate->precedingSpaces>0) {
                apply_spaces_to_source(asTemplate->precedingSpaces, parser, parsed_begin, parsed_end, outputBuffer, &bytesWritten);
                outputHead+=bytesWritten;
            }
        }
        else if (mstruct->type == STRUCTURE_TYPE_VAR) 
        {
            var_structure* asVar = (var_structure*)mstruct;
            const uint8_t* m_name_first = input + mstruct->contentsFirst;
            const uint8_t* m_name_end = input + mstruct->contentsEnd;
            const uint32_t nameLen = m_name_end - m_name_first;

            outputHead = mwrite(outputHead, outputEnd, lastNonEscaped, m_name_first - mstruct->precedingMustacheLen);
            lastNonEscaped = m_name_end + strlen("{{");

            /* HANDLE '.' CASE */
            if (*m_name_first == '.')
            {
                scoped_structure* parent = parent_stack_last(parentStack);
                mustache_param* m_child = parent->curChild;
                /* resolve '.' or chains '.member.name' */
                mustache_param* member = resolve_param_member(m_child, m_name_first, m_name_end);
                if (member) {
                    outputHead = write_variable(member, outputHead, outputEnd, asVar->escapeHTML);
                }
            }
            else if (!mstruct->param) {
                const uint8_t* m_first_end = m_name_first;
                while (m_first_end<m_name_end) {
                    if (*m_first_end == '.' || *m_first_end == '[') {
                        break;
                    }
                    m_first_end++;
                }

                
                mstruct->param = get_parameter(m_name_first, m_first_end, globalParams, parentStack);
                if (!mstruct->param) {
                    goto skip_node;
                }
                if (m_first_end != m_name_end) {
                    mustache_param* member = resolve_param_member(mstruct->param, m_first_end, m_name_end);
                    mstruct->param = member;
                }
            }
            if (mstruct->param) {
                outputHead = write_variable(mstruct->param, outputHead, outputEnd, asVar->escapeHTML);
                int p =0;
            }
        }
        else if (mstruct->type == STRUCTURE_TYPE_ELSE)
        {
            else_structure* asElse = (else_structure*)mstruct;
            const uint8_t* m_name_first = input + mstruct->contentsFirst + 1;
            const uint8_t* m_name_end = input + mstruct->contentsEnd;

            const uint8_t* interiorBegin = input + asElse->interiorBegin;
            const uint8_t* interiorEnd = input + asElse->contentsEnd;


            scoped_structure* parentAsScoped = (scoped_structure*)asElse->parent;

            if (!parentAsScoped->renderedLastEvaluation)
            {
                if (mstruct->standalone) {
                    const uint8_t* t = input + mstruct->standalone->lineBegin;
                    outputHead = mwrite(outputHead, outputEnd, lastNonEscaped, t);
                    lastNonEscaped = input + mstruct->standalone->lineEnd + strlen("\n");
                }
                else {
                    const uint8_t* t = m_name_first - strlen("{{x");
                    outputHead = mwrite(outputHead, outputEnd, lastNonEscaped, t);
                    lastNonEscaped = m_name_end + strlen("{{");
                }
            }
            else {
                uint32_t nameLen = m_name_end - m_name_first;
                const uint8_t* t;
                if (mstruct->standalone) {
                    t = input + mstruct->standalone->lineBegin;
                }
                else {
                    t = m_name_first - strlen("{{x");
                }
                outputHead = mwrite(outputHead, outputEnd, lastNonEscaped, t);
                lastNonEscaped = input + asElse->close->contentsEnd + strlen("}}");

                mstruct = (structure*)asElse->close;
                goto skip_node_no_advance;
            }
        }
        else if (mstruct->type == STRUCTURE_TYPE_SCOPED_CARET || mstruct->type == STRUCTURE_TYPE_SCOPED_POUND) {
            scoped_structure* asScoped = (scoped_structure*)mstruct;
        
            const uint8_t* m_name_first = input + mstruct->contentsFirst+1;
            const uint8_t* m_name_end = input + mstruct->contentsEnd;

            if (!mstruct->param) {

                const uint8_t* m_first_end = m_name_first;
                while (m_first_end < m_name_end) {
                    if (*m_first_end == '.' || *m_first_end == '[') {
                        break;
                    }
                    m_first_end++;
                }

                
                mstruct->param = get_parameter(m_name_first, m_first_end, globalParams, parentStack);
                if (!mstruct->param) {
                    goto skip_node;
                }

                if (m_first_end != m_name_end) {
                    mstruct->param = resolve_param_member(mstruct->param, m_first_end, m_name_end);
                }
            }

            asScoped->curIdx = 0;
            
            if (mstruct->type == STRUCTURE_TYPE_SCOPED_POUND && mstruct->param && is_parent(mstruct->param))
            {
                parent_stack_push(parentStack, asScoped);

                mustache_param_object* pAsObj = (mustache_param_object*)asScoped->param;
                asScoped->curChild = pAsObj->pMembers;

                if (mstruct->standalone) {
                    const uint8_t* t = input + mstruct->standalone->lineBegin;
                    outputHead = mwrite(outputHead, outputEnd, lastNonEscaped, t);
                    lastNonEscaped = input + mstruct->standalone->lineEnd + strlen("\n");
                }
                else {
                    const uint8_t* t = m_name_first - strlen("{{x");
                    outputHead = mwrite(outputHead, outputEnd, lastNonEscaped, t);
                    lastNonEscaped = m_name_end + strlen("{{");
                }
            }
            else if (mstruct->type == STRUCTURE_TYPE_SCOPED_POUND || mstruct->type==STRUCTURE_TYPE_SCOPED_CARET) 
            {
                
                scoped_structure* asScoped = (scoped_structure*)mstruct;
               
                if (!asScoped->wasEvaluated) {
                    bool truthy = is_truthy(mstruct->param);
                    asScoped->renderedLastEvaluation = (mstruct->type == STRUCTURE_TYPE_SCOPED_POUND && truthy) || (mstruct->type == STRUCTURE_TYPE_SCOPED_CARET && !truthy);
                    asScoped->wasEvaluated = true;
                }
                if (asScoped->renderedLastEvaluation)
                {
                    if (mstruct->standalone) {
                        const uint8_t* t = input + mstruct->standalone->lineBegin;
                        outputHead = mwrite(outputHead, outputEnd, lastNonEscaped, t);
                        lastNonEscaped = input + mstruct->standalone->lineEnd + strlen("\n");
                    }
                    else {
                        const uint8_t* t = m_name_first - strlen("{{x");
                        outputHead = mwrite(outputHead, outputEnd, lastNonEscaped, t);
                        lastNonEscaped = m_name_end + strlen("{{");
                    }
                }
                else {
                    uint32_t nameLen = m_name_end - m_name_first;
                    const uint8_t* t;
                    if (mstruct->standalone) {
                        t = input + mstruct->standalone->lineBegin;
                    } else {
                        t = m_name_first - strlen("{{x");
                    }
                    outputHead = mwrite(outputHead, outputEnd, lastNonEscaped, t);
                    lastNonEscaped = input + asScoped->interiorEnd+nameLen+strlen("{{x}}");

                    mstruct = asScoped->close_or_else;
                    goto skip_node_no_advance;
                }
            }
        }
        else if (mstruct->type == STRUCTURE_TYPE_COMMENT || mstruct->type == STRUCTURE_TYPE_CLOSE) 
        {
            const uint8_t* m_name_first = input + mstruct->contentsFirst+1;
            const uint8_t* m_name_end = input + mstruct->contentsEnd;

            if (mstruct->type == STRUCTURE_TYPE_CLOSE)
            {
                close_structure* asClose = (close_structure*)mstruct;

                if (!mstruct->param) {
                    mstruct->param = asClose->parent->param;
                }

                if (!asClose->parent) {
                    return MUSTACHE_ERR_INVALID_TEMPLATE;
                }

                scoped_structure* parent = asClose->parent;

                if (parent->type!=STRUCTURE_TYPE_ELSE && parent->param) {
                    if (parent->param->type == MUSTACHE_PARAM_LIST)
                    {
                        mustache_param_list* param = (mustache_param_list*)parent->param;
                        parent->curIdx++;
                        parent->curChild = parent->curChild->pNext;
                        if (parent->curIdx < param->valueCount && parent->curChild)
                        {

                            eval_jump(mstruct, m_name_first, m_name_end, input, outputEnd, &outputHead, &lastNonEscaped);

                            /* go to parent next again */
                            mstruct = (structure*)parent;
                            eval_jump(mstruct, m_name_first, m_name_end, input, outputEnd, &outputHead, &lastNonEscaped);
                            goto skip_node;
                        }
                        else if (mstruct->param && is_parent(mstruct->param)) {
                            parent_stack_pop(parentStack);
                        }
                    }
                }
            }

            eval_jump(mstruct, m_name_first, m_name_end, input, outputEnd, &outputHead, &lastNonEscaped);
        }

    skip_node:
        mstruct = mstruct->pNext;
    skip_node_no_advance:
        mstruct = mstruct;
    }


    outputHead = mwrite(outputHead, outputEnd, lastNonEscaped, inputEnd);
    *oh = outputHead;
    return MUSTACHE_SUCCESS;
}

void mustache_structure_chain_free(mustache_parser* p, mustache_structure* structure_chain)
{
    structure* root = (structure*)structure_chain;
    root = root->pNext;
    while (root)
    {
        structure* next = root->pNext;
        if (root->type == STRUCTURE_TYPE_VAR || root->type == STRUCTURE_TYPE_CLOSE || 
            root->type == STRUCTURE_TYPE_SCOPED_CARET || root->type == STRUCTURE_TYPE_SCOPED_POUND ||
            root->type == STRUCTURE_TYPE_ELSE 
        ) {
            if (root->standalone) {
                p->free(p,root->standalone);
            }
        }

        p->free(p,root);
        root = next;
    }

    memset(structure_chain, 0, sizeof(*structure_chain));
}

void mustache_structure_chain_flush(mustache_structure* structure_chain)
{
    structure* root = (structure*)structure_chain;
    root = root->pNext;
    while (root)
    {
        if (root->type == STRUCTURE_TYPE_SCOPED_CARET || root->type == STRUCTURE_TYPE_SCOPED_POUND)
        {
            scoped_structure* asScoped = (scoped_structure*)root;
        }
        root->param = NULL;
        root = root->pNext;
    }
}

uint8_t mustache_parse_file(mustache_parser* parser, mustache_slice parentStackBuffer, mustache_const_slice filename, mustache_structure* structChain, mustache_param* params, mustache_slice sourceBuffer, mustache_slice parseBuffer, void* parseCallbackUdata, mustache_parse_callback parseCallback)
{
#ifndef NDEBUG
    if (filename.len > 2048) {
        assert(00 && "mustache_parse_file: SUCH A LARGE FILENAME MAY RESULT IN PROGRAM INSTABILITY!");
    }
#endif
    /* tragically fopen requires a null terminated string, and there is no workaround even for an all-around */
    /* system specific design, it's possible on Windows but not on Linux to my knowledge :( */
    uint8_t* filenameNT = alloca(filename.len + 1);
    memcpy(filenameNT, filename.u, filename.len);
    filenameNT[filename.len] = 0;

    FILE* fptr;
    fptr = fopen(filenameNT, "rb");
    if (!fptr) {
        return MUSTACHE_ERR_FILE_OPEN;
    }

    /* parse in chunks */
    mustache_stream stream = {
        .udata = fptr,
        .readCallback = fread_callback,
        .seekCallback = fseek_callback,
    };

    uint8_t err = mustache_parse_stream(parser, parentStackBuffer, &stream, structChain, params, parseBuffer, sourceBuffer, parseCallbackUdata, parseCallback);
    fclose(fptr);
    return err;
}

uint8_t mustache_parse_stream(mustache_parser* parser, mustache_slice parentStackBuffer, mustache_stream* stream, mustache_structure* structChain,
    mustache_param* params, mustache_slice inputBuffer, mustache_slice outputBuffer, void* parseCallbackUdata, mustache_parse_callback parseCallback)
{
    uint8_t* inputHead = inputBuffer.u;
    uint8_t* inputBeg = inputBuffer.u;

    uint8_t* mustacheOpen = NULL;
    uint8_t* mustacheClose = inputBuffer.u;

    size_t streamLen = stream->seekCallback(stream->udata, 0, MUSTACHE_SEEK_LEN);
    size_t readBytes = stream->readCallback(stream->udata, inputBuffer.u, inputBuffer.len);
    if (readBytes < streamLen) {
        return MUSTACHE_ERR_NO_SPACE;
    }

    uint8_t* inputEnd = inputBuffer.u + readBytes;


    if (readBytes < 4 || readBytes >= UINT32_MAX-3) {
        return MUSTACHE_ERR_ARGS;
    }

    uint8_t* outputHead = outputBuffer.u;
    uint8_t* outputEnd = outputBuffer.u + outputBuffer.len;

    parent_stack parentStack = {
        .buf =  parentStackBuffer,
        .count = 0,
        .MAX_COUNT = parentStackBuffer.len / sizeof(void*)
    };

    structure* structureRoot = (structure*)structChain;

    MUSTACHE_RES err;
    if (!structureRoot->pNext) {
        err = source_to_structured(parser, structureRoot, inputBuffer.u, inputHead, inputEnd);
        if (err) {
            return err;
        }
    }
    else {

        /* RESET EVAL STATE */
        structure* root = (structure*)structureRoot;
        root = root->pNext;
        while (root)
        {
            if (root->type == STRUCTURE_TYPE_SCOPED_CARET || root->type == STRUCTURE_TYPE_SCOPED_POUND)
            {
                scoped_structure* asScoped = (scoped_structure*)root;
                asScoped->wasEvaluated = false;
            }
            root = root->pNext;
        }
    }

    err = write_structured(
        outputBuffer, &outputHead,
        (mustache_const_slice){ inputBuffer.u,inputBuffer.len },
        inputBuffer.u + readBytes,
        structureRoot, params, &parentStack,
        parser
    );

    if (err) {
        return err;
    }

    mustache_slice parsedSlice = {
        .u = outputBuffer.u,
        .len = outputHead - outputBuffer.u,
    };

    parseCallback(parser, parseCallbackUdata, parsedSlice);

    return MUSTACHE_SUCCESS;
}

















/* =#==#==#==#==#==#==#==#==#==#==#==#==#==#==#==#==#==#==#==#==#= */
/* -+- -+- -+- -+- -+- -+-  JSON  PARSING  -+- -+- -+- -+- -+- -+- */
/* =#==#==#==#==#==#==#==#==#==#==#==#==#==#==#==#==#==#==#==#==#= */

uint8_t mustache_JSON_to_param_chain_from_disk(mustache_parser* parser, mustache_const_slice filename, mustache_param** paramRoot)
{
#ifndef NDEBUG
    if (filename.len > 2048) {
        assert(00 && "mustache_parse_file: SUCH A LARGE FILENAME MAY RESULT IN PROGRAM INSTABILITY!");
    }
#endif
    /* tragically fopen requires a null terminated string, and there is no workaround even for an all-around */
    /* system specific design, it's possible on Windows but not on Linux to my knowledge :( */
    uint8_t* filenameNT = alloca(filename.len + 1);
    memcpy(filenameNT, filename.u, filename.len);
    filenameNT[filename.len] = 0;

    FILE* fptr;
    fptr = fopen(filenameNT, "rb");
    if (!fptr) {
        return MUSTACHE_ERR_FILE_OPEN;
    }

    fseek(fptr, 0, SEEK_END);
    uint32_t fileLen = ftell(fptr);
    rewind(fptr);

    void* JSON_buf;
    bool isBufferOnStack = fileLen < (16384);

    if (!isBufferOnStack) {
        JSON_buf = parser->alloc(parser, fileLen);
    }
    else {
        JSON_buf = alloca(fileLen);
    }

    fread(JSON_buf, 1, fileLen, fptr);

    uint8_t err = mustache_JSON_to_param_chain(parser, (mustache_const_slice){ JSON_buf, fileLen}, paramRoot, true);

    fclose(fptr);
    if (!isBufferOnStack) {
        parser->free(parser, JSON_buf);
    }
    return err;
}


static const uint8_t* JSON_get_object_close(const uint8_t* openingBracket, const uint8_t* sourceEnd)
{
#ifndef NDEBUG
    if (*openingBracket != '{') {
        assert(00 && "JSON_get_object_close: INVALID CALL, openingBracket MUST BE A PTR TO A '{'");
    }
#endif

    uint32_t depth = 0;
    while (openingBracket!=sourceEnd)
    {
        if (*openingBracket == '{') {
            depth++;
        }
        if (*openingBracket == '}') {
            depth--;
            if (depth == 0) {
                return openingBracket;
            }
        }
        openingBracket++;
    }
    return NULL;
}

static const uint8_t* JSON_get_list_close(const uint8_t* openingBracket, const uint8_t* sourceEnd)
{
#ifndef NDEBUG
    if (*openingBracket != '[') {
        assert(00 && "JSON_get_object_close: INVALID CALL, openingBracket MUST BE A PTR TO A '{'");
    }
#endif 

    uint32_t depth = 0;
    while (openingBracket != sourceEnd)
    {
        if (*openingBracket == '[') {
            depth++;
        }
        if (*openingBracket == ']') {
            depth--;
            if (depth == 0) {
                return openingBracket;
            }
        }
        openingBracket++;
    }
    return NULL;
}


static const uint8_t* JSON_get_string_end(const uint8_t* strFirst, const uint8_t* sourceEnd)
{
#ifndef NDEBUG
    if (*strFirst == '\"') {
        assert(00 && "JSON_get_string_end: INVALID CALL, strFirst MUST BE THE FIRST CHAR AFTER QUOTATION MARK OF THE STRING VALUE.");
    }
#endif 

    while (strFirst < sourceEnd)
    {
        if (*strFirst == '"') {
            return strFirst;
        }
        strFirst++;
    }

    return NULL;
}


static const uint8_t* JSON_get_number_end(const uint8_t* numFirst, const uint8_t* sourceEnd)
{
#ifndef NDEBUG
    if (!isdigit(*numFirst)) {
        assert(00 && "JSON_get_string_end: INVALID CALL, numFirst MUST BE A PTR TO THE FIRST DIGIT OF THE NUMBER.");
    }
#endif

    while (numFirst < sourceEnd)
    {
        if (!(isdigit(*numFirst) || *numFirst == '.')) {
            return numFirst;
        }
        numFirst++;
    }

    return sourceEnd;
}

static void JSON_number_to_mustache_number(mustache_param_number* param, const uint8_t* numBegin, const uint8_t* numEnd)
{
    /* first, find dec. place (if it exists) */
    const uint8_t* cur = numBegin;
    const uint8_t* dec = NULL;
    while (cur < numEnd)
    {
        if (*cur == '.') {
            dec = cur;
            break;
        }
        cur++;
    }

    if (!dec) {
        dec = numEnd;
    }
    param->value = 0;
    param->decimals = numEnd - dec;

    cur = numBegin;
    while (cur < dec) {
        uint32_t n = dec - cur - 1;
        param->value += n_pow10(n)*((*cur) - 48);
        cur++;
    }

    cur++;
    while (cur < numEnd) { 
        uint32_t n = cur - dec;
        double t = (*cur) - 48; 
        param->value += t / n_pow10(n); 
        cur++; 
    }


    double scale = n_pow10(param->decimals);
    param->value = round(param->value * scale) / scale;
}

/* FORWARD DECLARATION */
static uint8_t JSON_parse_object(mustache_parser* parser, mustache_param_object** objOut, const uint8_t** inputHead, const uint8_t* openingBracket, const uint8_t* sourceEnd, bool deepCopy);

static uint8_t JSON_parse_key(mustache_parser* parser, mustache_param** paramOut, const uint8_t** inputHead, 
    mustache_const_slice key_name, const uint8_t* keyEnd, const uint8_t* sourceEnd, bool deepCopy)
{
    const uint8_t* cur = keyEnd;

    /* find next non-whitespace / colon / " */
    while (cur < sourceEnd)
    {
        if (!isspace(*cur)) {
            break;
        }
        cur++;
    }
    if (cur >= sourceEnd) {
        return MUSTACHE_ERR_INVALID_JSON;
    }

    mustache_param* asGenParam = NULL;
    if (*cur == '"') 
    {
        const uint8_t* strBegin = cur + 1;
        /* PARAM IS A STRING */
        const uint8_t* strEnd = JSON_get_string_end(strBegin,sourceEnd);
        if (!strEnd) {
            return MUSTACHE_ERR_INVALID_JSON;
        }
        uint32_t strLen = strEnd - strBegin;

        mustache_param_string* param = parser->alloc(parser, sizeof(mustache_param_string));
        if (!param) {
            return MUSTACHE_ERR_ALLOC;
        }
        param->type = MUSTACHE_PARAM_STRING;
        asGenParam = (mustache_param*)param;

        if (strLen > 0) {
            if (deepCopy == true) {
                void* tmpstr = parser->alloc(parser, strLen);
                if (!tmpstr) {
                    return MUSTACHE_ERR_INVALID_JSON;
                }
                memcpy(tmpstr, strBegin, strLen);
                param->str.u = tmpstr;
            }
            else {
                param->str.u = (uint8_t*)strBegin;
            }
        }
        param->str.len = strLen;

        *inputHead = strEnd;
    }
    else if (*cur == '[') {
        /* PARAM IS A LIST */
        const uint8_t* listClose = JSON_get_list_close(cur, sourceEnd);
        if (!listClose) {
            return MUSTACHE_ERR_INVALID_JSON;
        }

        /* CREATE LIST PARAM */
        mustache_param_list* param = parser->alloc(parser, sizeof(mustache_param_list));
        if (!param) {
            return MUSTACHE_ERR_ALLOC;
        }
        param->type = MUSTACHE_PARAM_LIST;

        asGenParam = (mustache_param*)param;

        param->valueCount = 0;
        param->pValues = NULL;
        mustache_param* lastChildParam = NULL;

        cur++;
        const uint8_t* beg = NULL;
        /* parse all key value pairs in list */
        while (cur<listClose)
        {

            if (!(isspace(*cur) || *cur == ',')) {
                beg = cur;
                const uint8_t* end = NULL;
                while (cur < listClose) {
                    if (isspace(*cur) || *cur == ',' || cur == listClose) {
                        end = cur;
                        break;
                    }
                    cur++;
                }
                if (!end) {
                    return MUSTACHE_ERR_INVALID_JSON;
                }

                mustache_param* listChild = NULL;
                uint8_t err = JSON_parse_key(parser, &listChild, &cur, 
                    (mustache_const_slice) { NULL, 0 }, beg, end, true);
                if (err || !listChild) {
                    return MUSTACHE_ERR_INVALID_JSON;
                }

                if (lastChildParam) {
                    lastChildParam->pNext = listChild;
                }
                else {
                    param->pValues = listChild;
                }
                lastChildParam = listChild;
                param->valueCount++;
            }
            cur++;
        }

        *inputHead = listClose;
    }
    else if (*cur == '{') {
        /* PARAM IS AN OBJECT */
        mustache_param_object* param = NULL;
        uint8_t err = JSON_parse_object(parser, &param, inputHead, cur, sourceEnd, deepCopy);
        if (err || !param) {
            return err;
        }
        asGenParam = (mustache_param*)param;
    }
    else if (isdigit(*cur)) {
        const uint8_t* numBegin = cur;
        /* PARAM IS A NUMBER */
        const uint8_t* numEnd = JSON_get_number_end(numBegin,sourceEnd);
        if (!numEnd) {
            return MUSTACHE_ERR_INVALID_JSON;
        }

        mustache_param_number* param = parser->alloc(parser, sizeof(mustache_param_number));
        if (!param) {
            return MUSTACHE_ERR_ALLOC;
        }
        param->type = MUSTACHE_PARAM_NUMBER;

        asGenParam = (mustache_param*)param;

        param->trimZeros = false;
        JSON_number_to_mustache_number(param, numBegin, numEnd);

        *inputHead = numEnd;
    }
    else {
        /* PARAM MAY BE BOOLEAN */
        const uint8_t* end = get_key_value_end(cur, sourceEnd);
        if (!end) {
            return MUSTACHE_ERR_INVALID_JSON;
        }
        uint32_t len = end - cur;
        bool val;
        if (len == 4 && strneql(cur, "true", 4)) {
            val = true;
        }
        else if (len == 5 && strneql(cur, "false", 5)) {
            val = false;
        }
        else {
            /* INVALID PARAM OR PARAM IS NULL */
            *inputHead = end;
            return MUSTACHE_SUCCESS;
        }

        mustache_param_boolean* param = parser->alloc(parser, sizeof(mustache_param_boolean));
        if (!param) {
            return MUSTACHE_ERR_ALLOC;
        }
        param->type = MUSTACHE_PARAM_BOOLEAN;
        param->value = val;

        asGenParam = (mustache_param*)param;

        *inputHead = end;
    }

    if (!asGenParam) {
        return MUSTACHE_ERR_ALLOC;
    }

    if (key_name.len > 0) {
        if (deepCopy) {
            asGenParam->name.u = parser->alloc(parser, key_name.len);
            if (!asGenParam->name.u) {
                return MUSTACHE_ERR_ALLOC;
            }
            memcpy((uint8_t*)asGenParam->name.u, key_name.u, key_name.len);
        }
        else {
            asGenParam->name = key_name;
        }
    }
    else {
        asGenParam->name.u = NULL;
    }
    asGenParam->name.len = key_name.len;
    asGenParam->pNext = NULL;

    *paramOut = asGenParam;

    return MUSTACHE_SUCCESS;
}

static uint8_t JSON_parse_object(mustache_parser* parser, mustache_param_object** objOut, const uint8_t** inputHead, const uint8_t* openingBracket, const uint8_t* sourceEnd, bool deepCopy)
{
    const uint8_t* objClose = JSON_get_object_close(openingBracket, sourceEnd);
    if (!objClose) {
        return MUSTACHE_ERR_INVALID_JSON;
    }

    mustache_param* firstChild = NULL;
    mustache_param* lastParam = NULL;
    const uint8_t* cur = openingBracket + 1;
    while (cur < objClose)
    {
        /* get key name */
        if (*cur == '"') {
            const uint8_t* nameBeg = cur+1;
            const uint8_t* nameEnd = NULL;
            cur = nameBeg+1;
            while (cur <objClose)
            {
                if (*cur == '"') {
                    nameEnd = cur;
                    break;
                }
                cur++;
            }
            if (!nameEnd) {
                return MUSTACHE_ERR_INVALID_JSON;
            }

            const uint8_t* colonEnd=nameEnd+1;
            while (colonEnd < objClose+1) {
                if (*colonEnd == ':') {
                    colonEnd++;
                    break;
                }
                colonEnd++;
            }

            mustache_const_slice keyName = { nameBeg, nameEnd - nameBeg };
            /* get value */
            mustache_param* param = NULL;
            uint8_t err = JSON_parse_key(parser, &param, &cur, keyName, colonEnd, objClose+1, deepCopy);
            if (err) {
                return err;
            }
            if (param) {
                if (lastParam) {
                    lastParam->pNext = param;
                }
                else {
                    firstChild = param;
                }
                lastParam = param;
            }
        }
        cur++;
    }

    *inputHead = objClose;

    mustache_param_object* obj = parser->alloc(parser, sizeof(mustache_param_object));
    if (!obj) {
        return MUSTACHE_ERR_ALLOC;
    }
    obj->type = MUSTACHE_PARAM_OBJECT;
    obj->pMembers = firstChild;
    *objOut = obj;

    return MUSTACHE_SUCCESS;
}

uint8_t mustache_JSON_to_param_chain(mustache_parser* parser, mustache_const_slice JSON, mustache_param** paramRoot, bool deepCopy)
{
    const uint8_t* jsonBeg = JSON.u;
    const uint8_t* cur = jsonBeg;
    const uint8_t* jsonEnd = JSON.u + JSON.len;

    uint8_t err = MUSTACHE_SUCCESS;

    while (cur < jsonEnd)
    {
        if (*cur == '{') 
        {
            mustache_param_object* root = NULL;
            err = JSON_parse_object(parser, &root, &cur, cur, jsonEnd, deepCopy);
            if (err) {
                break;
            }
            root->name.u = parser->alloc(parser, 4);
            if (!root->name.u)
                return MUSTACHE_ERR_ALLOC;

            memcpy((uint8_t*)root->name.u, "root", 4);
            root->name.len = strlen("root");
            root->pNext = NULL;
            *paramRoot = (mustache_param*)root;
            break; /*ONLY 1 ROOT ALLOWED AS PER JSON STANDARD*/ 
        }
        cur++;
    }

    return err;
}



/*FORWARD DECLARATION*/
static void mustache_free_node(mustache_parser* parser, mustache_param* node, bool deepCopy);

static void mustache_free_children(mustache_parser* parser, mustache_param* parent, bool deepCopy)
{
    uint32_t MAX_COUNT;
    mustache_param_list* asList = (mustache_param_list*)parent;
    if (parent->type == MUSTACHE_PARAM_LIST) {
        MAX_COUNT = asList->valueCount;
    }
    else {
        MAX_COUNT = UINT32_MAX;
    }

    mustache_param* child = asList->pValues;
    uint32_t i = 0;
    while (child && i < MAX_COUNT)
    {
        mustache_param* next = child->pNext;
        mustache_free_node(parser, child, deepCopy);
        child = next;
        ++i;
    }
}

static void mustache_free_node(mustache_parser* parser, mustache_param* node, bool deepCopy)
{
    if (deepCopy && node->name.u) {
        parser->free(parser, (uint8_t*)node->name.u);
    }
    if (node->type == MUSTACHE_PARAM_STRING) {
        mustache_param_string* asStr = (mustache_param_string*)node;
        if (deepCopy && asStr->str.u) {
            parser->free(parser, asStr->str.u);
        }
    } 
    else if (node->type == MUSTACHE_PARAM_LIST || node->type == MUSTACHE_PARAM_OBJECT) {
        mustache_free_children(parser, node, deepCopy);
    }
    parser->free(parser, node);
}

uint8_t mustache_free_param_list(mustache_parser* parser, mustache_param* paramRoot, bool deepCopy)
{
    mustache_free_node(parser, paramRoot, deepCopy);

    return MUSTACHE_SUCCESS;
}








#ifdef MUSTACHE_SYSTEM_TESTS
#include <stdio.h>


static void mustache_print_list(mustache_param* ____, int depth)
{
    mustache_param_list* obj = (mustache_param_list*)____;
    mustache_param* node = obj->pValues;
    uint32_t i = 0;
    while (node && i < obj->valueCount)
    {
        mustache_print_node(node, depth+1);
        printf("\n");
        node = node->pNext;
        i++;
    }
}

static void mustache_print_object(mustache_param* ____, int depth)
{
    mustache_param_object* obj = (mustache_param_object*)____;
    mustache_param* node = obj->pMembers;
    while (node)
    {
        mustache_print_node(node,depth+1);
        printf("\n");
        node = node->pNext;
    }
}

void mustache_print_node(mustache_param* node, int depth)
{
    for (int i = 0; i < depth; ++i) {
        printf("   ");
    }
    if (node->type == MUSTACHE_PARAM_LIST) {
        if (node->name.u) {
            if (node->name.len) {
                printf("\"%.*s\": [\n", node->name.len, node->name.u);
            }
            mustache_print_list(node, depth);

            for (int i = 0; i < depth; ++i) {
                printf("   ");
            }
            printf("]");
        }
    }
    else if (node->type == MUSTACHE_PARAM_OBJECT) {
        if (node->name.len) {
            printf("\"%.*s\": {\n", node->name.len, node->name.u);
        }
        mustache_print_object(node, depth);

        for (int i = 0; i < depth; ++i) {
            printf("   ");
        }
        printf("}");
    }
    else if (node->type == MUSTACHE_PARAM_STRING) {
        mustache_param_string* nstr = (mustache_param_string*)node;
        if (node->name.len) {
            printf("\"%.*s\": ", node->name.len, node->name.u);
        }
        printf("\"%.*s\"", nstr->str.len, nstr->str.u);
    }
    else if (node->type == MUSTACHE_PARAM_NUMBER) {
        mustache_param_number* nno = (mustache_param_number*)node;
        if (node->name.len) {
            printf("\"%.*s\": ", node->name.len, node->name.u);
        }
        printf("%f", nno->value);
    }
    else if (node->type == MUSTACHE_PARAM_BOOLEAN) {
        mustache_param_boolean* nbool = (mustache_param_boolean*)node;
        if (node->name.len) {
            printf("\"%.*s\": ", node->name.len, node->name.u);
        }
        if (nbool->value) {
            printf("true");
        }
        else {
            printf("false");
        }
    }
    else {
        printf("\"%.*s\": !!INVALID PARAMETER!!", node->name.len, node->name.u);
    }
}

void mustache_print_parameter_list(mustache_param* root)
{
    while (root)
    {
        mustache_print_node(root,0);
        root = root->pNext;
    }
}

#endif